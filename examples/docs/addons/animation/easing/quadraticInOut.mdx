---
title: 'quadraticInOut'
description: 'Bidirectional quadratic easing combining acceleration and deceleration phases'
keywords: [animation, easing, quadratic, bidirectional, acceleration, deceleration]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# quadraticInOut: Symmetric Parabolic Transform Function

### Mathematical Foundation for Dual-Phase Motion

The `quadraticInOut` function combines quadratic acceleration and deceleration through piecewise polynomial construction. This creates symmetric motion profiles with smooth transitions between phases.

$$
f(t) = \begin{cases}
2t^2 & \text{if } t < 0.5 \\
-2t^2 + 4t - 1 & \text{if } t \geq 0.5
\end{cases}
$$

The piecewise definition ensures continuous motion across the midpoint transition while maintaining quadratic characteristics in both phases.

### Velocity Profile Analysis

The derivative reveals symmetric acceleration and deceleration patterns around the midpoint.

$$
\frac{df}{dt} = \begin{cases}
4t & \text{if } t < 0.5 \\
-4t + 4 & \text{if } t \geq 0.5
\end{cases}
$$

This creates maximum velocity at $t = 0.5$ with symmetric velocity profiles on either side, ensuring smooth motion transitions.

### Symmetry Properties

The function exhibits perfect symmetry around the center point $(0.5, 0.5)$, where acceleration transitions seamlessly to deceleration.

$$
f(0.5 - \delta) + f(0.5 + \delta) = 1 \quad \text{for small } \delta
$$

### Practical Animation Applications

Bidirectional quadratic easing suits complete motion cycles: drawer toggles, accordion expansions, and reversible animations where both acceleration and deceleration phases require smooth handling.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const t = iTime.fract()
        const linear = t
        const quadInOut = quadraticInOut(t)
        const linearCurve = uv.x.sub(linear).abs().sub(0.01).step(0)
        const quadCurve = uv.x.sub(quadInOut).abs().sub(0.01).step(0)
        const marker = t.sub(uv.x).abs().sub(0.005).step(0)
        return vec4(quadCurve.add(marker), linearCurve, quadCurve.add(linearCurve), 1)
}`}
/>

The implementation demonstrates symmetric motion behavior where acceleration and deceleration phases create balanced animation cycles with smooth velocity transitions.
