---
title: 'blendColorBurn'
description: 'Dramatic color burn blending that creates deep shadows and rich contrast through mathematical darkening'
keywords: ['blend', 'colorburn', 'shadow', 'contrast', 'darken', 'dramatic']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# blendColorBurn: Dramatic Shadow Enhancement

### Mathematical Foundation of Color Burn

Color burn creates dramatic darkening effects by inverting the blend color and dividing the base by the inverted blend. This mathematical approach intensifies shadows while preserving highlights, creating high-contrast artistic effects.

The mathematical definition is:

$$
C_{result} = \begin{cases}
0 & \text{if } C_{blend} = 0 \\
\max\left(0, 1 - \frac{1 - C_{base}}{C_{blend}}\right) & \text{otherwise}
\end{cases}
$$

The division operation creates non-linear darkening that becomes more pronounced as blend values approach zero, generating deep shadow regions with preserved detail.

### Shadow Enhancement Properties

| Property                   | Description                           | Visual Effect             |
| -------------------------- | ------------------------------------- | ------------------------- |
| **Shadow Amplification**   | Dark areas become dramatically darker | Deep, rich shadows        |
| **Highlight Preservation** | Bright areas maintain luminosity      | Selective darkening       |
| **Contrast Enhancement**   | Increases overall dynamic range       | Dramatic tonal separation |
| **Zero Protection**        | Prevents division by zero             | Stable computation        |

<FragmentEditor
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const angle = uv.y.sub(center.y).atan2(uv.x.sub(center.x))
        const radius = uv.sub(center).length()
        const base = vec3(
                radius.mul(20).sin().mul(0.3).add(0.7),
                angle.mul(3).cos().mul(0.2).add(0.6),
                radius.mul(1.5)
        )
        const burn = vec3(
                float(0.2).smoothstep(0.8, uv.x),
                float(0.1).smoothstep(0.9, uv.y),
                uv.x.add(uv.y).mul(8).sin().mul(0.3).add(0.4)
        )
        const result = blendColorBurnVec3(base, burn)
        return vec4(result, 1)
}`}
/>
