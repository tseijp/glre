---
title: 'blendPhoenix'
description: 'Value harmony detector illuminating concordance while darkening discordance'
keywords: ['blend', 'phoenix', 'harmony', 'concordance', 'difference', 'equality']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# blendPhoenix: Harmony Detection System

### Concordance Illumination Algorithm

Phoenix blending functions as a value harmony detector, generating brightness when colors match and darkness when they differ. The algorithm rewards concordance with light and punishes discordance with shadow.

$$
C_{result} = \min(C_{base}, C_{blend}) - \max(C_{base}, C_{blend}) + 1
$$

| Condition              | Calculation      | Result                  |
| ---------------------- | ---------------- | ----------------------- |
| **Equal Values**       | $x - x + 1 = 1$  | White (maximum harmony) |
| **Maximum Difference** | $0 - 1 + 1 = 0$  | Black (maximum discord) |
| **Close Values**       | Small difference | Bright tones            |
| **Distant Values**     | Large difference | Dark tones              |

<FragmentEditor
        code={`
const fragment = () => {
        const diagonalA = uv.x.add(uv.y).div(2)
        const diagonalB = uv.x.sub(uv.y).add(1).div(2)
        const color = blendPhoenixVec3(
                vec3(diagonalA),
                vec3(diagonalB)
        )
        return vec4(color, 1)
}`}
/>
