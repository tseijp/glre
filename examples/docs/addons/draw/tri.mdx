---
title: 'tri'
description: 'Equilateral triangle rendering with distance field precision and stroke control'
keywords: [triangle, equilateral, distance field, fill, stroke, geometry]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# tri: Distance Field Triangle Rendering

### Equilateral Triangle Distance Mathematics

The `tri` functions render equilateral triangles using analytical distance field calculations. The triangle distance field employs geometric relationships specific to 60-degree angular symmetry.

For triangular distance fields:

$$
\text{triSDF}(p) = \max(|p_x| \cdot \frac{\sqrt{3}}{2} + p_y \cdot 0.5, -p_y \cdot 0.5)
$$

Where $\frac{\sqrt{3}}{2} \approx 0.866025$ represents the cosine of 30 degrees, essential for equilateral triangle geometry.

Triangle rendering applies:

$$
\text{triFill}(p, s) = \text{fill}(\text{triSDF}(p), s)
$$

$$
\text{triStroke}(p, s, w) = \text{stroke}(\text{triSDF}(p), s, w)
$$

### Geometric Properties and Symmetry

The triangle implementation produces perfect equilateral triangles with threefold rotational symmetry. Each interior angle measures exactly 60 degrees, maintaining geometric consistency at any scale.

The distance field calculation handles the complex boundary conditions where triangle edges meet, ensuring smooth transitions and accurate distance measurements throughout the coordinate space.

### Size Control and Orientation

Size parameter controls triangle scale uniformly across all three sides. The triangle maintains its equilateral proportions regardless of size, with the base positioned horizontally and apex pointing upward.

Distance field triangles support all standard distance field operations including boolean combinations, morphing effects, and complex geometric transformations without quality degradation.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(6)
        const grid = p.fract().sub(0.5)
        const rotation = p.x.add(p.y).mul(0.3).add(iTime)
        const size = sin(rotation.mul(2)).mul(0.15).add(0.3)
        const triangles = triFill(grid, size)
        return vec4(triangles.mul(vec3(0.9, 0.6, 0.2)), 1)
}`}
/>

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(5)
        const result = float(0).toVar()
        const layers = int(6)
        Loop(layers, ({ i }) => {
                const t = float(i).div(float(layers))
                const angle = t.mul(6.28).add(iTime.mul(1.2))
                const radius = sin(t.mul(9.42).add(iTime.mul(0.8))).mul(0.8).add(1.2)
                const center = vec2(cos(angle), sin(angle)).mul(radius)
                const size = cos(t.mul(15.7).add(iTime.mul(1.8))).mul(0.2).add(0.4)
                const strokeWidth = sin(angle.mul(3).add(iTime.mul(2.5))).mul(0.03).add(0.06)
                const triangle = triStroke(p.sub(center), size, strokeWidth)
                result.addAssign(triangle)
        })
        return vec4(result.clamp(0, 1).mul(vec3(0.3, 0.8, 0.5)), 1)
}`}
/>