---
title: 'hex'
description: 'Regular hexagon rendering with distance field precision and stroke control'
keywords: [hexagon, distance field, fill, stroke, regular, geometry]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# hex: Distance Field Hexagon Rendering

### Hexagon Distance Field Mathematics

The `hex` functions render regular hexagons using analytical distance field calculations. The hexagon distance field employs geometric relationships specific to six-sided regular polygons.

For hexagonal distance fields:

$$
\text{hexSDF}(p) = \max(|p_y|, p_x \cdot \frac{\sqrt{3}}{2} + p_y \cdot 0.5)
$$

Where $\frac{\sqrt{3}}{2} \approx 0.866025$ represents the geometric factor for hexagonal symmetry, and coordinates are normalized to [-1,1] space.

Hexagon rendering applies:

$$
\text{hexFill}(p, s) = \text{fill}(\text{hexSDF}(p), s)
$$

$$
\text{hexStroke}(p, s, w) = \text{stroke}(\text{hexSDF}(p), s, w)
$$

### Regular Hexagon Properties

The implementation produces perfect regular hexagons with sixfold rotational symmetry. Each interior angle measures exactly 120 degrees, maintaining geometric consistency at any scale.

The distance field calculation handles the complex boundary conditions where hexagon edges meet, ensuring accurate distance measurements and smooth edge transitions throughout the coordinate space.

### Size Control and Geometric Precision

Size parameter controls hexagon scale uniformly across all six sides. The hexagon maintains perfect regularity regardless of size, with flat edges positioned to create optimal tiling patterns.

Distance field hexagons support all standard distance field operations including boolean combinations, morphing effects, and complex geometric transformations without quality degradation.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(8)
        const grid = p.fract().sub(0.5)
        const offset = floor(p)
        const hexSize = sin(offset.x.add(offset.y).mul(0.8).add(iTime)).mul(0.15).add(0.3)
        const hexagons = hexFill(grid, hexSize)
        return vec4(hexagons.mul(vec3(0.7, 0.9, 0.5)), 1)
}`}
/>

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(6)
        const result = float(0).toVar()
        const layers = int(5)
        Loop(layers, ({ i }) => {
                const t = float(i).div(float(layers))
                const angle = t.mul(6.28).add(iTime.mul(1.5))
                const radius = sin(iTime.add(t.mul(3.14))).mul(0.8).add(1.5)
                const center = vec2(cos(angle), sin(angle)).mul(radius)
                const size = cos(t.mul(12.56).add(iTime.mul(2))).mul(0.2).add(0.4)
                const strokeWidth = sin(angle.mul(2).add(iTime.mul(2.5))).mul(0.03).add(0.05)
                const h = hexStroke(p.sub(center), size, strokeWidth)
                result.addAssign(h)
        })
        return vec4(result.clamp(0, 1).mul(vec3(0.2, 0.8, 0.7)), 1)
}`}
/>