---
title: 'point'
description: 'Point marker rendering with position, color and size control'
keywords: [point, marker, visualization, circle, position]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# point: Position Marker Visualization

### Point Marker Mathematics

The `point` function renders circular markers at specified positions with customizable color and radius. It provides a simplified interface for position-based visualization tasks.

Point rendering applies:

$$
\text{point}(p, pos, c, r) = \text{vec4}(c, 1) \cdot \text{circleFill}(p - pos + 0.5, r)
$$

Where p is the current coordinate, pos is the point position, c is the color, and r is the radius.

### Position and Color Control

The point function translates coordinate space so the point appears at the specified position. Color parameters accept RGB values, automatically setting alpha to 1.0 for opaque rendering.

The radius parameter controls point size in distance field units, maintaining consistent visual scale across different coordinate systems and transformations.

### Simplified Implementation Note

This implementation focuses on core point rendering functionality. The original GLSL version includes complex digit display features for debugging coordinate values, which would require extensive bitmap font implementation beyond the scope of basic drawing primitives.

The simplified version provides clean point marker functionality suitable for data visualization, debugging overlays, and interactive graphics applications.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.mul(2)
        const grid = vec2(4, 3)
        const cellSize = vec2(2).div(grid)
        let result = vec4(0, 0, 0, 1).toVar()
        Loop(int(grid.x.mul(grid.y)), ({ i }) => {
                const idx = vec2(float(i).mod(grid.x), float(i).div(grid.x).floor())
                const pos = idx.mul(cellSize).add(cellSize.mul(0.5))
                const phase = idx.x.add(idx.y).add(iTime.mul(2))
                const color = vec3(sin(phase), cos(phase.mul(1.3)), sin(phase.mul(0.7))).mul(0.5).add(0.5)
                const radius = sin(phase.mul(3)).mul(0.02).add(0.04)
                const pointColor = point2D(p, pos, color, radius)
                result = result.add(pointColor.mul(pointColor.a))
        })
        return result
}`}
/>

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.mul(3)
        let result = vec4(0, 0, 0, 1).toVar()
        const points = int(8)
        Loop(points, ({ i }) => {
                const t = float(i).div(float(points)).mul(6.28)
                const radius = sin(iTime.add(t.mul(2))).mul(0.3).add(0.8)
                const angle = t.add(iTime.mul(0.5))
                const pos = vec2(cos(angle), sin(angle)).mul(radius).add(1.5)
                const hue = t.add(iTime).mod(6.28)
                const color = vec3(sin(hue), sin(hue.add(2.09)), sin(hue.add(4.19))).mul(0.5).add(0.5)
                const pointRadius = cos(iTime.mul(3).add(t)).mul(0.03).add(0.05)
                const pointColor = point2D(p, pos, color, pointRadius)
                result = result.add(pointColor.mul(pointColor.a))
        })
        return result
}`}
/>