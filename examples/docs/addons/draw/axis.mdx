---
title: 'axis'
description: '3D coordinate axis visualization with perspective projection and color coding'
keywords: [axis, 3D, coordinate, visualization, projection, transform]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# axis: 3D Coordinate System Visualization

### Perspective Projection Mathematics

The `axis` function renders 3D coordinate axes by projecting world-space lines onto screen coordinates through matrix transformation. Each axis receives distinct color coding for spatial orientation clarity.

For perspective projection:

$$
p_{screen} = \frac{M \cdot p_{world}}{w} \cdot 0.5 + 0.5
$$

Where M represents the combined model-view-projection matrix and w is the homogeneous coordinate component for perspective division.

### Axis Color Convention

The function follows standard 3D graphics conventions for axis coloring:

| Axis | Direction | Color | RGB Value |
|------|-----------|-------|-----------|
| X | Right/Left | Red | (1,0,0) |
| Y | Up/Down | Green | (0,1,0) |
| Z | Forward/Back | Blue | (0,0,1) |

This RGB-XYZ mapping provides intuitive spatial reference for 3D scene debugging and coordinate system visualization.

### Matrix Transformation Pipeline

The rendering process transforms both the center position and each axis endpoint through the provided transformation matrix. Line segments connect the center to each unit-length axis endpoint, creating a clear directional indicator.

Screen-space coordinates are normalized to [0,1] range for compatibility with standard UV coordinate systems used in fragment rendering contexts.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv
        const t = iTime.mul(0.5)
        const rotX = mat4(
                1, 0, 0, 0,
                0, cos(t), sin(t).negate(), 0,
                0, sin(t), cos(t), 0,
                0, 0, 0, 1
        )
        const rotY = mat4(
                cos(t.mul(0.7)), 0, sin(t.mul(0.7)), 0,
                0, 1, 0, 0,
                sin(t.mul(0.7)).negate(), 0, cos(t.mul(0.7)), 0,
                0, 0, 0, 1
        )
        const transform = rotY.mul(rotX)
        const axes = axis(p, transform, vec3(0.5), 0.008)
        return vec4(axes.rgb, max(axes.r, max(axes.g, axes.b)))
}`}
/>

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv
        const t = iTime
        const scale = sin(t.mul(0.3)).mul(0.3).add(0.7)
        const rotAngle = t.mul(0.4)
        const translation = vec3(sin(t.mul(0.2)).mul(0.1), cos(t.mul(0.15)).mul(0.1), 0)
        
        const scaleMatrix = mat4(
                scale, 0, 0, 0,
                0, scale, 0, 0,
                0, 0, scale, 0,
                0, 0, 0, 1
        )
        const rotMatrix = mat4(
                cos(rotAngle), sin(rotAngle).negate(), 0, 0,
                sin(rotAngle), cos(rotAngle), 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
        )
        const transMatrix = mat4(
                1, 0, 0, translation.x,
                0, 1, 0, translation.y,
                0, 0, 1, translation.z,
                0, 0, 0, 1
        )
        
        const combined = transMatrix.mul(rotMatrix).mul(scaleMatrix)
        const axes = axis(p, combined, vec3(0.5), 0.012)
        const brightness = max(axes.r, max(axes.g, axes.b))
        return vec4(axes.rgb.mul(brightness.add(0.2)), brightness)
}`}
/>