---
title: 'flip'
description: 'Value inversion with interpolation control for creating negative and mixed effects'
keywords: [flip, invert, mix, interpolation, negative, blend]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# flip: Controlled Value Inversion

### Interpolated Inversion Mathematics

The `flip` function performs controlled inversion of values through interpolation between original and inverted states. It enables gradual transitions from positive to negative representations.

For any input value v and percentage pct:

$$
\text{flip}(v, pct) = \text{mix}(v, 1 - v, pct)
$$

Where pct = 0 returns the original value and pct = 1 returns the fully inverted value.

### Linear Interpolation Control

The percentage parameter provides linear control over inversion intensity. Intermediate values create partial inversion effects, useful for creating smooth transitions between positive and negative states.

This approach maintains value range consistency while providing fine-grained control over the inversion process, enabling creative effects and smooth animations.

### Multi-Type Support

Flip functions operate on scalar floats, 3D vectors (RGB colors), and 4D vectors (RGBA colors). The inversion applies component-wise for vector types, maintaining mathematical consistency across all supported data types.

The generic version uses automatic type inference, providing flexible usage patterns while preserving type safety and mathematical correctness.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(4)
        const pattern = sin(p.x.mul(3)).add(cos(p.y.mul(2))).mul(0.3).add(0.5)
        const time = iTime.mul(0.8)
        const flipAmount = sin(time).mul(0.5).add(0.5)
        const flipped = flip(pattern, flipAmount)
        return vec4(flipped.mul(vec3(0.8, 0.9, 0.6)), 1)
}`}
/>

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(6)
        const grid = p.fract().sub(0.5)
        const dist = grid.length()
        const time = iTime.mul(0.5)
        const baseColor = vec3(
                sin(p.x.add(time)),
                cos(p.y.add(time.mul(1.3))),
                sin(p.length().add(time.mul(0.7)))
        ).mul(0.4).add(0.6)
        const flipMask = smoothstep(0.2, 0.4, dist)
        const flipIntensity = sin(time.mul(2).add(p.x.add(p.y))).mul(0.5).add(0.5)
        const finalFlip = flipMask.mul(flipIntensity)
        const result = flipVec3(baseColor, finalFlip)
        return vec4(result, 1)
}`}
/>