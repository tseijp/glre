---
title: 'fill'
description: 'Anti-aliased shape filling function for distance field rendering'
keywords: [fill, distance field, anti-aliased, step function, smoothstep]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# fill: Shape Interior Calculation with Smooth Boundaries

### Mathematical Foundation for Distance Field Rendering

The `fill` function converts distance field values into interior/exterior classifications with controlled edge smoothing. It implements two mathematical approaches for boundary detection.

For edge-controlled filling:

$$
\text{fill}(x, s, e) = 1 - \text{smoothstep}(s - e, s + e, x)
$$

For anti-aliased filling:

$$
\text{fill}(x, s) = 1 - \text{aastep}(s, x)
$$

Where `aastep` incorporates screen-space derivatives for pixel-perfect edge smoothing.

### Distance Field Interior Detection

Distance fields represent shape boundaries as zero-crossings. The `fill` function transforms these continuous distance values into binary interior classifications. Values below the threshold receive full intensity (1.0), while values above receive zero intensity (0.0).

The edge parameter controls the transition width. Smaller edges create sharper boundaries, while larger edges produce softer, more blurred transitions. This mathematical relationship enables precise control over visual appearance without modifying underlying geometry.

### Anti-Aliasing Through Derivative Analysis

The standard `fill(x, size)` function employs derivative-based anti-aliasing. It analyzes how rapidly the distance field changes across screen pixels, automatically adjusting the smoothing width to prevent aliasing artifacts.

This approach eliminates staircase patterns and flickering that occur when distance field boundaries align poorly with pixel grids. The derivative calculation ensures consistent visual quality regardless of viewing angle or scale.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(4)
        const d1 = p.length().sub(1)
        const d2 = p.abs().max().sub(0.8)
        const shape = d1.min(d2)
        const layers = fill(shape.add(sin(p.length().mul(8)).mul(0.1)), 0)
        return vec4(layers.mul(vec3(0.2, 0.8, 1)), 1)
}`}
/>

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(6)
        const grid = p.fract().sub(0.5)
        const d = grid.abs().max().sub(0.3)
        const ripples = sin(p.length().mul(2).sub(iTime.mul(3))).mul(0.15)
        const filled = fillWithEdge(d.add(ripples), 0, 0.1)
        return vec4(filled.mul(vec3(1, 0.4, 0.2)), 1)
}`}
/>
