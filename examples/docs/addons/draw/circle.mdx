---
title: 'circle'
description: 'Circular shape rendering with distance field precision and stroke control'
keywords: [circle, distance field, fill, stroke, radius, geometry]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# circle: Distance Field Circle Rendering

### Circle Distance Field Mathematics

The `circle` functions render circular shapes using distance field calculations. They compute the Euclidean distance from each point to the circle boundary and apply fill or stroke operations.

For circular distance fields:

$$
\text{circleSDF}(p) = |p - c| \cdot 2
$$

Where c is the circle center (typically 0.5 for normalized coordinates) and the result is scaled by 2 for unit circle representation.

Circle rendering applies:

$$
\text{circleFill}(p, r) = \text{fill}(\text{circleSDF}(p), r)
$$

$$
\text{circleStroke}(p, r, w) = \text{stroke}(\text{circleSDF}(p), r, w)
$$

### Radius Parameter Control

The size parameter controls circle radius in distance field units. Unlike pixel-based approaches, distance field circles maintain perfect roundness at any scale and provide sub-pixel precision for smooth edges.

Stroke width operates independently of radius, enabling thin outlines on large circles or thick borders on small circles without geometric distortion.

### Anti-Aliasing and Edge Quality

Distance field circles automatically provide anti-aliasing through the underlying fill and stroke operations. Edge smoothness adapts to screen resolution, eliminating pixelation artifacts common in rasterized circular rendering.

The analytical nature of distance field circles enables perfect circular arcs, complex boolean operations, and seamless combination with other geometric primitives.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(6)
        const grid = p.fract().sub(0.5)
        const radius = sin(p.length().mul(2).sub(iTime.mul(3))).mul(0.15).add(0.25)
        const circles = circleFill(grid, radius)
        return vec4(circles.mul(vec3(0.8, 0.3, 0.6)), 1)
}`}
/>

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const p = uv.sub(0.5).mul(4)
        const result = float(0).toVar()
        const rings = int(8)
        Loop(rings, ({ i }) => {
                const t = float(i).div(float(rings))
                const angle = t.mul(6.28).add(iTime.mul(2))
                const radius = sin(iTime.add(t.mul(3.14))).mul(0.3).add(0.7)
                const center = vec2(cos(angle), sin(angle)).mul(radius)
                const size = cos(t.mul(12.56).add(iTime.mul(3))).mul(0.2).add(0.3)
                const strokeWidth = sin(t.mul(18.84).add(iTime.mul(1.5))).mul(0.02).add(0.04)
                const c = circleStroke(p.sub(center), size, strokeWidth)
                result.addAssign(c)
        })
        return vec4(result.clamp(0, 1).mul(vec3(0.2, 0.7, 0.9)), 1)
}`}
/>