---
title: 'rotate4dY'
description: 'Optimized 4D homogeneous Y-axis rotation matrix'
keywords: ['rotation', '4D', 'Y-axis', 'homogeneous', 'navigation', 'space']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# rotate4dY: Specialized Four-Dimensional Y-Axis Rotation

### Homogeneous Y-Axis Transformation Theory

The `rotate4dY` function generates a specialized 4×4 homogeneous rotation matrix for rotations around the Y-axis in projective coordinate space. This transformation preserves the Y-coordinate and homogeneous W-coordinate while rotating vectors in the XZ-plane.

The 4×4 Y-axis rotation matrix follows the mathematical form:

$$
R_{4D,y}(\theta) = \begin{pmatrix}
\cos\theta & 0 & \sin\theta & 0 \\
0 & 1 & 0 & 0 \\
-\sin\theta & 0 & \cos\theta & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

### Dimensional Navigation and Spatial Topology

Y-axis rotation in homogeneous space exhibits profound mathematical connections to navigation systems and spatial topology:

**Yaw Navigation**: Fundamental operation for horizontal orientation changes in 3D navigation systems.

**Topological Preservation**: Maintains spatial relationships while enabling continuous orientation changes.

**Projective Stability**: Ensures stable behavior under perspective transformations and camera operations.

### Molecular Orbital Electron Dynamics

This example visualizes quantum mechanical electron orbitals under rotational symmetry, demonstrating how Y-axis rotation reveals the mathematical structure of atomic electron probability distributions in four-dimensional phase space.

<FragmentEditor
        code={`
const fragment = () => {
    const center = vec3(0.5, 0.5, 0)
    const pos = vec3(uv, iTime.mul(0.3).sin().mul(0.2)).sub(center).mul(6)
    const orbitalAngle = pos.length().mul(1.5).add(iTime.mul(0.5))
    const rotation = rotate4dY(orbitalAngle)
    const orbital = rotation.mul(vec4(pos, 1))
    const radial = orbital.length()
    const angular = orbital.z.atan2(orbital.x).mul(3)
    const probability = radial.negate().exp().mul(angular.sin().pow(2))
    const electron = probability.mul(smoothstep(0.1, 0.3, probability))
    const energy = radial.mul(0.1).add(0.5)
    const color = vec3(electron.mul(0.4), electron.mul(energy), electron)
    return vec4(color, 1)
}`}
/>
