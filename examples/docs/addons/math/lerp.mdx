---
title: 'lerp'
description: 'Linear interpolation bridges dimensional boundaries, creating seamless transformations between mathematical states through temporal metamorphosis'
keywords: [glre, lerp, linear interpolation, transformation, temporal, metamorphosis, dimensional, blending]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# Dimensional Metamorphosis Engine

### Basic Linear Interpolation

Linear interpolation (lerp) blends between two values using a parameter t. It's simply an alias for GLSL's `mix()` function, providing smooth transitions between any two values - numbers, vectors, or colors.

The mathematical foundation:
$$lerp(a, b, t) = a \cdot (1-t) + b \cdot t = a + t \cdot (b-a)$$

Where $t \in [0,1]$ controls the morphological transition between state $a$ and state $b$, creating infinite intermediate realities within the transformation continuum.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const morphTime = iTime.mul(0.8).sin().mul(0.5).add(0.5)
        const origin = vec2(0.3, 0.7)
        const destination = vec2(0.7, 0.3)
        const currentPos = origin.mix(destination, morphTime)
        const distanceField = uv.sub(currentPos).length()
        const morphingCircle = smoothstep(0.15, 0.1, distanceField)
        const energyField = smoothstep(0.4, 0.0, distanceField).pow(2).mul(0.3)
        return vec4(morphingCircle.add(energyField).mul(0.8), morphingCircle.mul(1.2), morphingCircle.add(energyField), 1)
}`}
/>

### Complex Multi-Layer Blending

Multiple lerp operations can be combined to create complex blending patterns. This is useful for creating smooth transitions between multiple states or creating layered animation effects.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const timePhase = iTime.mul(0.4)
        const coord = uv.sub(0.5).mul(4)
        const stateA = coord.x.mul(3).add(timePhase).sin().mul(coord.y.mul(2).add(timePhase.mul(1.3)).sin())
        const stateB = coord.x.mul(2.5).add(timePhase.mul(0.7)).cos().mul(coord.y.mul(3.2).add(timePhase.mul(1.8)).cos())
        const stateC = coord.length().mul(4).add(timePhase.mul(2)).sin().mul(0.8)
        const probability1 = coord.x.add(coord.y).add(timePhase).sin().mul(0.5).add(0.5)
        const probability2 = coord.x.sub(coord.y).add(timePhase.mul(1.2)).cos().mul(0.5).add(0.5)
        const superposition1 = stateA.mix(stateB, probability1)
        const superposition2 = stateB.mix(stateC, probability2)
        const finalSuperposition = superposition1.mix(superposition2, timePhase.mul(0.8).sin().mul(0.5).add(0.5))
        const cloudDensity = finalSuperposition.abs().pow(0.7)
        const energyDistribution = cloudDensity.mul(1.5)
        return vec4(energyDistribution.mul(0.6), energyDistribution.mul(0.9), energyDistribution.mul(1.3), 1)
}`}
/>
