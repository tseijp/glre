---
title: 'pow3'
description: 'Cubic power function that transforms linear input through dimensional expansion into three-dimensional resonance patterns'
keywords: [cubic, power, nonlinear, transformation, dimensional]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# pow3: Cubic Dimensional Transformation Engine

### Mathematical Foundation of Cubic Amplification

The `pow3` function represents the fundamental cubic transformation $f(x) = x^3$, where linear input undergoes dimensional expansion through triple self-multiplication. This operation exhibits unique mathematical properties including sign preservation, accelerating growth rates, and the critical inflection behavior at unity.

$$
\text{pow3}(x) = x \cdot x \cdot x = x^3
$$

The cubic function demonstrates asymmetric scaling behavior: for $|x| < 1$, values compress toward zero with characteristic cubic decay $x^3 < x$, while for $|x| > 1$, explosive growth occurs following $x^3 > x$. The unity point $x = 1$ represents the transformation invariant where $1^3 = 1$.

### Crystalline Harmonic Interference Visualization

This implementation generates three-dimensional acoustic crystals through cubic amplitude modulation. Each point undergoes cubic transformation, creating resonance chambers that interfere constructively and destructively across the visual field. The cubic scaling produces natural harmonic overtones visible as geometric crystal formations.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const baseFreq = iTime.mul(0.3)
        const pos = uv.sub(0.5).mul(8.0)
        
        const resonanceX = pos.x.add(baseFreq).sin()
        const resonanceY = pos.y.add(baseFreq.mul(1.618)).cos()
        const resonanceZ = pos.x.mul(pos.y).add(baseFreq.mul(2.414)).sin()
        
        const cubicAmplifier = pow3(resonanceX.add(resonanceY).mul(0.4))
        const harmonicCore = pow3(resonanceZ.mul(0.6))
        
        const interference = cubicAmplifier.add(harmonicCore)
        const crystalStructure = interference.abs().fract()
        
        const intensity = crystalStructure.pow(0.5)
        const hue = pos.length().mul(0.1).add(iTime.mul(0.1)).fract()
        
        const red = hue.mul(6.28).sin().mul(0.5).add(0.5).mul(intensity)
        const green = hue.mul(6.28).add(2.09).sin().mul(0.5).add(0.5).mul(intensity)  
        const blue = hue.mul(6.28).add(4.19).sin().mul(0.5).add(0.5).mul(intensity)
        
        return vec4(red, green, blue, 1)
}`}
/>

### Metamorphic Temporal Distortion Field

Advanced demonstration showcasing cubic transformation applied to temporal flow fields. The pow3 function creates non-uniform time dilation effects, where regions experience accelerated or decelerated temporal progression based on cubic scaling laws. This generates organic morphing patterns that evolve through dimensional phase transitions.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const centerPos = uv.sub(0.5)
        const radius = centerPos.length()
        const angle = centerPos.y.atan2(centerPos.x)
        
        const temporalBase = iTime.mul(0.8).add(radius.mul(3.0))
        const cubicTimeWarp = pow3(temporalBase.sin().mul(0.7))
        
        const morphField1 = angle.add(cubicTimeWarp).sin().mul(radius)
        const morphField2 = angle.mul(2.0).add(pow3(cubicTimeWarp.mul(1.3))).cos()
        
        const distortionMagnitude = pow3(morphField1.add(morphField2.mul(0.6)))
        const phase = distortionMagnitude.mul(5.0).add(iTime)
        
        const wave1 = phase.sin()
        const wave2 = phase.mul(1.732).cos()
        const wave3 = pow3(phase.mul(0.577)).sin()
        
        const composite = wave1.add(wave2.mul(0.8)).add(wave3.mul(0.6))
        const normalized = composite.mul(0.4).add(0.5)
        
        const dynamicHue = radius.add(angle.mul(0.159)).add(iTime.mul(0.2))
        const r = dynamicHue.mul(6.28).sin().mul(normalized)
        const g = dynamicHue.mul(6.28).add(2.09).sin().mul(normalized)
        const b = dynamicHue.mul(6.28).add(4.19).sin().mul(normalized)
        
        return vec4(r.abs(), g.abs(), b.abs(), 1)
}`}
/>