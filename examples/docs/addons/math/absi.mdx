---
title: 'absi'
description: 'High-performance absolute value calculations optimized for integer and vector data types'
keywords: [integer absolute value, mathematical operations, vector processing, conditional logic]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# Integer Absolute Value Operations

## Conditional Value Processing

The `absi` function performs intelligent conditional processing to ensure all numeric values become positive. This operation examines each input value and applies selective transformation based on mathematical sign determination.

Unlike standard absolute value functions, `absi` maintains computational precision across different numeric types while providing consistent behavior for both scalar and vector operations.

<FragmentEditor
        code={`
const fragment = () => {
        const uv = position.xy.div(iResolution).sub(0.5).mul(2)

        // Create symmetric patterns using absolute value
        const pattern = absi(uv.x.mul(8).sin().sub(0.3))
        const color = vec3(pattern)

        return vec4(color, 1)

}`}
/>

## Dynamic Threshold Visualization

Threshold-based visual effects leverage absolute value operations to create dynamic boundaries that respond to mathematical conditions and time-based parameters.

<FragmentEditor
        code={`
const fragment = () => {
        const uv = position.xy.div(iResolution).sub(0.5).mul(4)
        const time = iTime.mul(0.8)

        // Create dynamic threshold patterns
        const noise1 = uv.x.mul(3).add(time).sin().mul(uv.y.mul(2).sub(time.mul(0.7)).cos())
        const noise2 = uv.x.mul(1.5).sub(time.mul(0.5)).cos().add(uv.y.mul(4).add(time.mul(1.2)).sin())

        const threshold = time.mul(2).sin().mul(0.4)

        const pattern1 = absi(noise1.sub(threshold))
        const pattern2 = absi(noise2.add(threshold.mul(0.8)))

        const finalPattern = pattern1.mul(pattern2)

        const color = vec3(
                finalPattern.mul(time.sin().mul(0.5).add(0.7)),
                finalPattern.mul(time.mul(1.3).cos().mul(0.5).add(0.6)),
                finalPattern.mul(time.mul(0.7).sin().mul(0.5).add(0.5))
        )

        return vec4(color, 1)

}`}
/>

## Implementation Architecture

### Mathematical Foundation

The `absi` function implements conditional logic through mathematical comparison operations:

$$
\text{absi}(x) = \begin{cases}
x \cdot (-1) & \text{if } x < 0 \\
x & \text{otherwise}
\end{cases}
$$

This can be expressed as a branchless operation:
$$\text{absi}(x) = x \cdot \text{sign}(x) \cdot \text{sign}(x)$$

Or using conditional selection:
$$\text{absi}(x) = \text{select}(x, -x, x < 0)$$

The function ensures optimal execution across different processing architectures by avoiding branching penalties.

### Computational Structure

| Operation Phase      | Mathematical Logic            | Implementation Detail                   |
| -------------------- | ----------------------------- | --------------------------------------- |
| Sign Detection       | Negative value identification | `x.lessThan(0)`                         |
| Conditional Negation | Selective value inversion     | `x.mul(-1)`                             |
| Value Selection      | Conditional result choice     | `select(negative, positive, condition)` |
