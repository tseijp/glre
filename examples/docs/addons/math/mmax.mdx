---
title: 'mmax'
description: 'Multidimensional maximum extraction creating dimensional dominance visualization through mathematical supremacy analysis'
keywords: ['maximum', 'multidimensional', 'supremacy', 'dominance', 'optimization', 'vector', 'component']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# mmax: Multidimensional Supremacy Detector

### Mathematical Dominance Analysis Through Component Competition

The mmax function extracts the dominant component from multidimensional vectors, revealing hierarchical relationships between dimensional coordinates. This mathematical supremacy detection creates visualization patterns where the strongest dimensional influence governs the entire spatial region.

Through component-wise comparison, mmax establishes mathematical dominance hierarchies that transform multidimensional data into scalar fields representing dimensional authority. The function operates as a dimensional filter that identifies which coordinate axis exerts maximum influence at each spatial location.

Mathematical Definition:

$$\text{mmax}(\mathbf{v}) = \max\{v_1, v_2, v_3, v_4\}$$

For 4-dimensional vector space analysis:

$$\mathbf{v} \in \mathbb{R}^4 \Rightarrow \text{mmax}(\mathbf{v}) = v_i \text{ where } i = \arg\max_j v_j$$

The supremacy function establishes order relationships:

$$\forall \mathbf{v} \in \mathbb{R}^n: \text{mmax}(\mathbf{v}) \geq v_i \quad \forall i \in \{1,2,\ldots,n\}$$

This creates mathematical landscapes where dimensional competition determines local characteristics. The resulting scalar field represents regions where specific coordinate dimensions achieve dominance over others, producing complex interference patterns through mathematical optimization principles.

The visualization demonstrates how competing mathematical forces create emergent structures through dimensional supremacy, where local maxima represent stable states in the multidimensional competition system.

<FragmentEditor
	isFun
	code={`
const fragment = () => {
	const time = iTime.mul(0.4)
	const center = vec2(0.0)
	const coord = uv.sub(center)
	
	const freq1 = coord.mul(3.2).add(time.mul(0.8))
	const freq2 = coord.mul(2.1).add(time.mul(1.3))
	const freq3 = coord.mul(4.7).add(time.mul(0.6))
	const freq4 = coord.mul(1.9).add(time.mul(2.1))
	
	const wave1 = freq1.x.sin().mul(freq1.y.cos())
	const wave2 = freq2.x.cos().mul(freq2.y.sin().mul(1.4))
	const wave3 = freq3.length().mul(7.0).sin().mul(0.7)
	const wave4 = freq4.x.add(freq4.y).mul(2.3).cos().mul(1.1)
	
	const competition = vec4(wave1, wave2, wave3, wave4)
	const supremacy = mmax(competition)
	
	const influence = supremacy.abs().pow(1.8)
	
	const resonance1 = coord.length().mul(8.0).add(supremacy.mul(4.0)).sin()
	const resonance2 = coord.x.mul(coord.y).mul(12.0).add(influence.mul(6.0)).cos()
	const resonance3 = supremacy.mul(resonance1).mul(resonance2).abs()
	
	const r = influence.mul(resonance3).pow(0.6)
	const g = resonance1.abs().mul(influence).pow(1.2)
	const b = resonance2.abs().mul(supremacy.abs()).pow(2.0)
	
	return vec4(r, g, b, 1)
}`}
/>