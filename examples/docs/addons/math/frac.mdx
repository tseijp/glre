---
title: 'frac'
description: 'Extract fractional components to create infinite tiling patterns, crystalline structures, and mathematical harmony in visual space'
keywords: [glre, frac, fractional, modulo, tiling, crystalline, infinite, mathematical, patterns]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# Fractional Universe Generator

### Mathematical Foundation

The fractional function extracts the decimal portion of numbers, transforming continuous mathematical space into repeating, crystalline structures. This fundamental operation enables the creation of infinite tiling patterns, geometric repetitions, and mathematical harmonies that extend beyond the boundaries of conventional space.

**Fractional Function Formula:**
$$\text{frac}(x) = x - \lfloor x \rfloor$$

Where:

- $x$ is the input value
- $\lfloor x \rfloor$ is the floor function (greatest integer less than or equal to $x$)
- The result is always in the range $[0, 1)$

This can also be expressed as:
$$\text{frac}(x) = x \bmod 1$$

The function creates a sawtooth wave pattern that repeats every unit interval:

$$
\text{frac}(x) = \begin{cases}
x & \text{if } 0 \leq x < 1 \\
x - 1 & \text{if } 1 \leq x < 2 \\
x - 2 & \text{if } 2 \leq x < 3 \\
\vdots
\end{cases}
$$

By capturing only the fractional remainder, complex coordinate systems collapse into elegant, repeating units that form the foundation for procedural textures, architectural patterns, and natural crystalline formations.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const tiled = frac(uv.mul(8.0))
        const pattern = smoothstep(0.1, 0.2, tiled.x).mul(smoothstep(0.1, 0.2, tiled.y))
        const gradient = tiled.sub(0.5).length().mul(2)
        return vec4(vec3(pattern.mul(gradient)), 1)
}`}
/>

### Dimensional Fractal Architecture

The fractional function enables construction of self-similar architectural structures that exist across multiple dimensional scales. Each fractional layer creates geometric recursion, building infinite complexity from simple mathematical principles.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const pos = uv.sub(0.5).mul(6)
        const layer1 = frac(pos.mul(1))
        const layer2 = frac(pos.mul(3))
        const layer3 = frac(pos.mul(9))

        const structure = layer1.x.mul(layer1.y).add(
                layer2.x.mul(layer2.y).mul(0.5)
        ).add(
                layer3.x.mul(layer3.y).mul(0.25)
        )

        const depth = structure.mul(PI).add(iTime.mul(2)).sin().abs()
        const architectural = smoothstep(0.2, 0.8, depth)

        return vec4(architectural.mul(1.3), architectural.mul(0.8), architectural.mul(0.4), 1)

}`}
/>
