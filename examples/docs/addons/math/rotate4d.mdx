---
title: 'rotate4d'
description: '4D homogeneous coordinate rotation matrix using Rodrigues formula'
keywords: ['rotation', '4D', 'homogeneous', 'matrix', 'projection', 'transformation']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# rotate4d: Four-Dimensional Homogeneous Rotation Matrix

### Homogeneous Coordinate System Implementation

The `rotate4d` function constructs a 4×4 rotation matrix in homogeneous coordinates, extending 3D axis-angle rotation into the projective space framework commonly used in computer graphics pipelines. This transformation maintains the mathematical elegance of Rodrigues' formula while enabling seamless integration with perspective projection systems.

The 4×4 homogeneous rotation matrix takes the form:

$$
R_{4D}(\mathbf{n}, \theta) = \begin{pmatrix}
R_{3D}(\mathbf{n}, \theta) & \mathbf{0} \\
\mathbf{0}^T & 1
\end{pmatrix}
$$

Where $R_{3D}$ represents the 3×3 Rodrigues rotation matrix embedded within the larger homogeneous structure.

### Mathematical Properties of Projective Transformations

Homogeneous coordinates enable sophisticated geometric operations through projective geometry principles:

**Affine Invariance**: The transformation preserves affine properties while maintaining compatibility with perspective projection.

**Pipeline Integration**: Seamless composition with translation, scaling, and projection matrices in graphics pipelines.

**Projective Completeness**: Enables representation of points at infinity and unified treatment of parallel projections.

### Hyperdimensional Shadow Projection

This demonstration explores the mathematical concept of dimensional projection, visualizing how 4D rotations cast shadows into lower-dimensional spaces, creating intricate patterns that reveal the hidden geometry of higher dimensions.

<FragmentEditor
    isFun
    code={`
const fragment = () => {
    const center = vec3(0.5, 0.5, 0)
    const pos = vec3(uv, sin(iTime.mul(0.1)).mul(0.3)).sub(center).mul(3)
    const axis1 = vec3(1, 1, 1).normalize()
    const axis2 = vec3(1, -1, 0).normalize()
    const rotation1 = rotate4d(axis1, iTime.mul(0.4))
    const rotation2 = rotate4d(axis2, iTime.mul(0.6))
    const composed = rotation1.mul(rotation2)
    const transformed = composed.mul(vec4(pos, 1))
    const projection = transformed.xyz.div(transformed.w.add(1))
    const distance = projection.length()
    const shadow = smoothstep(1.5, 0.5, distance)
    const depth = projection.z.mul(0.5).add(0.5)
    const color = vec3(shadow.mul(depth), shadow, shadow.mul(0.6))
    return vec4(color, 1)
}`}
/>

### Tesseract Wireframe Visualization

This example attempts to visualize the rotation of a 4D hypercube (tesseract) through its 3D projection, demonstrating how homogeneous transformations enable exploration of geometric objects beyond our spatial intuition.

<FragmentEditor
    isFun
    code={`
const fragment = () => {
    const center = vec3(0.5, 0.5, 0)
    const pos = vec3(uv, 0).sub(center).mul(4)
    const axis = vec3(0.7, 0.7, 0).normalize()
    const rotation = rotate4d(axis, iTime.mul(0.3))
    const corners = vec4(pos, 1)
    const rotated = rotation.mul(corners)
    const projected = rotated.xyz.div(rotated.w.add(2))
    const grid = abs(sin(projected.x.mul(4))).mul(abs(sin(projected.y.mul(4))))
    const edges = smoothstep(0.9, 1.0, grid)
    const vertices = smoothstep(0.02, 0.0, projected.length().mod(0.5))
    const structure = edges.add(vertices)
    const color = vec3(structure.mul(0.8), structure.mul(0.9), structure)
    return vec4(color, 1)
}`}
/>