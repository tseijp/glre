---
title: 'gain'
description: 'Advanced gain control for extreme contrast manipulation, color intensity amplification, and psychedelic visual transformations'
keywords: [glre, gain, contrast, amplifier, color, intensity, psychedelic, transformation]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# Dynamic Contrast Amplifier

### Mathematical Foundation: Asymmetric Power-Law Transformation

The gain function implements a sophisticated contrast control mechanism through asymmetric power-law transformations that treat values above and below the midpoint differently.

**Mathematical Definition:**

$$
\text{gain}(x, k) = \begin{cases}
\frac{1}{2} \cdot \left(2x\right)^k & \text{if } x < 0.5 \\
1 - \frac{1}{2} \cdot \left(2(1-x)\right)^k & \text{if } x \geq 0.5
\end{cases}
$$

**Parameter Analysis:**

- $x \in [0, 1]$: Input value (normalized intensity)
- $k > 0$: Gain parameter controlling contrast intensity
- When $k = 1$: Linear transformation (identity)
- When $k > 1$: Enhanced contrast with sharper transitions
- When $0 < k < 1$: Reduced contrast with smoother gradients

**Geometric Properties:**
The function creates an S-shaped curve that passes through (0,0), (0.5,0.5), and (1,1), maintaining monotonicity while providing precise control over the contrast curve's steepness around the midpoint.

### Intelligent Intensity Modulation

This mathematical approach enables precise control over visual punch, creating effects that range from subtle artistic enhancement to extreme psychedelic transformations, all while maintaining mathematical elegance and computational simplicity.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const intensity = sin(iTime).add(1).div(2).mul(4).add(1)
        const pattern = sin(uv.x.mul(PI.mul(8))).mul(sin(uv.y.mul(PI.mul(6))))
        const enhanced = gain(pattern.add(1).div(2), intensity)
        return vec4(vec3(enhanced), 1)
}`}
/>

### Fractal Contrast Architecture

Multiple gain layers with different intensity parameters create complex fractal contrast structures. Each layer enhances different aspects of the base pattern, building architectural depth through mathematical precision rather than geometric complexity.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const coord = uv.sub(0.5).mul(4)
        const basePattern = sin(coord.x.mul(PI)).mul(cos(coord.y.mul(PI)))
        const normalized = basePattern.add(1).div(2)

        const time = iTime.mul(0.4)
        const gain1 = sin(time).add(1).mul(3).add(0.5)
        const gain2 = cos(time.mul(1.3)).add(1).mul(2).add(1)
        const gain3 = sin(time.mul(0.7)).add(1).mul(4).add(0.8)

        const layer1 = gain(normalized, gain1)
        const layer2 = gain(layer1, gain2)
        const layer3 = gain(layer2, gain3)

        const final = layer3.mul(0.8).add(layer2.mul(0.15)).add(layer1.mul(0.05))

        return vec4(final.mul(0.9), final.mul(1.1), final.mul(0.7), 1)

}`}
/>

### Quantum Field Visualization

Gain modulation creates quantum-like field effects where energy densities appear to fluctuate according to mathematical probability distributions. The non-linear gain curve mimics quantum energy states, creating visual representations of theoretical physics concepts.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const quantumTime = iTime.mul(0.8)
        const field1 = sin(uv.x.mul(12).add(quantumTime)).mul(cos(uv.y.mul(8).add(quantumTime.mul(1.2))))
        const field2 = cos(uv.x.mul(6).sub(quantumTime.mul(0.8))).mul(sin(uv.y.mul(10).add(quantumTime.mul(0.6))))

        const interference = field1.add(field2).div(2)
        const probability = interference.add(1).div(2)

        const energy1 = sin(quantumTime.mul(2.1)).add(1).mul(5).add(1)
        const energy2 = cos(quantumTime.mul(1.7)).add(1).mul(3).add(2)

        const quantum1 = gain(probability, energy1)
        const quantum2 = gain(probability.oneMinus(), energy2)

        const superposition = quantum1.add(quantum2).div(2)
        const collapse = pow(superposition, sin(quantumTime.mul(3)).add(1).mul(2).add(1))

        return vec4(collapse.mul(0.4), collapse.mul(1.2), collapse.mul(0.8), 1)

}`}
/>
