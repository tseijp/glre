---
title: 'scale2d'
description: '2D scaling transformation matrix generator with geometric synthesis capabilities'
keywords: ['scale2d', 'matrix', 'transformation', 'geometry', 'linear algebra']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# scale2d: Geometric Transformation Matrix Engine

### Parametric Scaling Matrix Construction for Spatial Deformation

The scale2d function generates 2×2 transformation matrices for coordinate space scaling operations. This function provides three distinct parametric forms: uniform scalar scaling $S(s)$, vector-based anisotropic scaling $S(\mathbf{v})$, and explicit component scaling $S(x,y)$.

The mathematical foundation operates through matrix representation:

$$
S(s) = \begin{bmatrix}
s & 0 \\
0 & s
\end{bmatrix}
$$

$$
S(x,y) = \begin{bmatrix}
x & 0 \\
0 & y
\end{bmatrix}
$$

For anisotropic transformations, the scaling matrix enables differential compression and expansion along orthogonal axes. The determinant $\det(S) = xy$ represents the area scaling factor, while eigenvalues $(x,y)$ determine principal scaling directions.

### Circle to Ellipse Transformation

Demonstrates how scale2d transforms perfect circles into ellipses by applying different scaling factors to X and Y axes, showing the fundamental geometric effect of non-uniform scaling.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
    const center = vec2(0.5)
    const p = uv.sub(center).mul(3)
    
    // Original circle equation: x² + y² = r²
    const originalCircle = length(p)
    
    // Time-varying anisotropic scaling
    const scaleX = sin(iTime.mul(0.7)).mul(0.6).add(1.5)
    const scaleY = cos(iTime.mul(0.5)).mul(0.8).add(1.2)
    
    // Apply inverse scaling to coordinate space
    // This transforms circles into ellipses
    const scaledP = vec2(p.x.div(scaleX), p.y.div(scaleY))
    const transformedCircle = length(scaledP)
    
    // Show multiple concentric ellipses
    const ellipse1 = abs(transformedCircle.sub(0.5))
    const ellipse2 = abs(transformedCircle.sub(1.0))
    const ellipse3 = abs(transformedCircle.sub(1.5))
    
    const rings = smoothstep(0.05, 0.02, ellipse1).add(
                 smoothstep(0.05, 0.02, ellipse2).mul(0.7)).add(
                 smoothstep(0.05, 0.02, ellipse3).mul(0.4))
    
    // Color shows aspect ratio
    const aspectRatio = scaleX.div(scaleY)
    const eccentricity = abs(aspectRatio.sub(1)).div(aspectRatio.add(1))
    
    return vec4(vec3(
        rings.mul(aspectRatio.div(3)),
        rings.mul(eccentricity.add(0.3)),
        rings.mul(float(2).sub(aspectRatio).div(2).add(0.2))
    ), 1)
}`}
/>

### Checkerboard Distortion Analysis

Shows how scale2d affects regular grid patterns, revealing compression and stretching effects through visual distortion of a checkerboard pattern.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
    const p = uv.mul(8)
    
    // Dynamic scaling factors
    const time = iTime.mul(0.6)
    const scaleX = sin(time).mul(0.5).add(1.2)
    const scaleY = cos(time.mul(1.3)).mul(0.7).add(1.1)
    
    // Apply scaling to create distorted checkerboard
    const scaledX = p.x.mul(scaleX)
    const scaledY = p.y.mul(scaleY)
    
    // Create checkerboard pattern in scaled space
    const checkerX = floor(scaledX).mod(2)
    const checkerY = floor(scaledY).mod(2)
    const checker = checkerX.add(checkerY).mod(2)
    
    // Show grid lines to visualize deformation
    const gridX = smoothstep(0.05, 0.1, abs(scaledX.mod(1).sub(0.5)))
    const gridY = smoothstep(0.05, 0.1, abs(scaledY.mod(1).sub(0.5)))
    const grid = min(gridX, gridY)
    
    // Visualize scaling effects
    const compression = min(scaleX, scaleY)
    const stretch = max(scaleX, scaleY).div(min(scaleX, scaleY))
    const area = scaleX.mul(scaleY)
    
    const pattern = checker.mul(0.8).add(grid.mul(0.3))
    
    return vec4(vec3(
        pattern.mul(compression),
        pattern.mul(stretch.div(3)),
        pattern.mul(area.div(3))
    ), 1)
}`}
/>

### Scaling Matrix Visualization

Direct visualization of how scale2d matrix elements affect coordinate transformations, showing the mathematical relationship between matrix components and geometric deformation.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
    const center = uv.sub(0.5).mul(6)
    const time = iTime.mul(0.8)
    
    // Create scaling matrix with time-varying elements
    const sx = sin(time).mul(0.8).add(1.5)
    const sy = cos(time.mul(0.7)).mul(0.6).add(1.3)
    
    // Original coordinate grid
    const originalX = center.x
    const originalY = center.y
    
    // Transform coordinates using scale2d matrix
    // [sx  0 ] [x]   [sx*x]
    // [0  sy ] [y] = [sy*y]
    const transformedX = originalX.mul(sx)
    const transformedY = originalY.mul(sy)
    
    // Create pattern showing transformation
    const originalPattern = sin(originalX.mul(2)).mul(cos(originalY.mul(2)))
    const transformedPattern = sin(transformedX.mul(2)).mul(cos(transformedY.mul(2)))
    
    // Blend between original and transformed
    const blend = sin(time.mul(2)).mul(0.5).add(0.5)
    const pattern = mix(originalPattern, transformedPattern, blend)
    
    // Color encodes matrix properties
    const determinant = sx.mul(sy)
    const trace = sx.add(sy)
    const eigenRatio = sx.div(sy)
    
    const intensity = smoothstep(-0.3, 0.3, pattern)
    
    return vec4(vec3(
        intensity.mul(determinant.div(4)),
        intensity.mul(trace.div(5)),
        intensity.mul(eigenRatio.div(3))
    ), 1)
}`}
/>
