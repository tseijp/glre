---
title: 'aamirror'
description: 'Create smooth mirrored patterns with automatic anti-aliasing for high-quality visual effects'
keywords: [mirror, pattern, anti-aliasing, smooth, wave, periodic]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# Anti-Aliased Mirror Function

## Function Overview

The `aamirror` function creates a mirrored pattern that automatically applies anti-aliasing to eliminate visual artifacts. This function transforms input values into smooth, symmetric waves that repeat with perfect mirroring.

### Mathematical Foundation

The anti-aliased mirror function creates symmetric patterns through mathematical transformation and filtering:

$$v = \left| x - \lfloor x + 0.5 \rfloor \right| \cdot 2.0$$

The anti-aliasing width calculation:
$$\text{afwidth} = \left\|\frac{d}{dx}(x), \frac{d}{dy}(x)\right\|$$

The result is processed through Nyquist filtering for smooth transitions:
$$\text{aamirror}(x) = \text{nyquist}(v, \text{afwidth})$$

Where the Nyquist filter applies:
$$\text{nyquist}(v, w) = \text{smoothstep}(0, w, v)$$

This creates perfect mirror symmetry with automatic anti-aliasing that adapts to screen pixel density.

### Core Implementation Logic

| Component               | Purpose                     | Mathematical Expression              |
| ----------------------- | --------------------------- | ------------------------------------ |
| **Mirror Transform**    | Creates symmetric pattern   | `abs(x - floor(x + 0.5)) * 2.0`      |
| **Anti-aliasing Width** | Calculates smoothing factor | `length(vec2(dFdx(x), dFdy(x)))`     |
| **Nyquist Filter**      | Prevents aliasing artifacts | `mix(0.5, pattern, smoothstep(...))` |

## Basic Mirror Pattern

Create fundamental mirrored waves that repeat seamlessly across space.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const x = uv.x.mul(8.0)
        const mirror = aamirror(x)
        const color = vec3(mirror)
        return vec4(color, 1)
}`}
/>

## Animated Mirror Waves

Generate dynamic mirror patterns that evolve over time while maintaining smooth transitions.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const freq = 6.0
        const speed = 2.0
        const x = uv.x.mul(freq).add(iTime.mul(speed))
        const mirror = aamirror(x)
        const wave = mirror.mul(0.8).add(0.2)
        const color = vec3(wave)
        return vec4(color, 1)
}`}
/>

## Multi-Directional Mirror Grid

Combine horizontal and vertical mirroring to create complex geometric patterns.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const scale = 4.0
        const mirrorX = aamirror(uv.x.mul(scale))
        const mirrorY = aamirror(uv.y.mul(scale))
        const pattern = mirrorX.mul(mirrorY)
        const color = vec3(pattern)
        return vec4(color, 1)
}`}
/>

## Distorted Mirror Field

Apply spatial distortions to mirror patterns for organic, fluid effects.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const distortion = sin(uv.y.mul(8.0)).mul(0.3)
        const x = uv.x.mul(6.0).add(distortion)
        const mirror = aamirror(x)
        const intensity = mirror.pow(2.0)
        const color = vec3(intensity.mul(0.9).add(0.1))
        return vec4(color, 1)
}`}
/>

## Layered Mirror Harmonics

Stack multiple mirror frequencies to generate rich, harmonic textures.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const pos = uv.mul(3.0)
        const layer1 = aamirror(pos.x)
        const layer2 = aamirror(pos.x.mul(2.0)).mul(0.5)
        const layer3 = aamirror(pos.x.mul(4.0)).mul(0.25)
        const combined = layer1.add(layer2).add(layer3).div(1.75)
        const color = vec3(combined)
        return vec4(color, 1)
}`}
/>

## Mirror-Based Interference

Create interference patterns by combining phase-shifted mirror functions.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const freq = 5.0
        const phase1 = uv.x.mul(freq)
        const phase2 = uv.y.mul(freq).add(float(3.14159).div(4.0))
        const mirror1 = aamirror(phase1)
        const mirror2 = aamirror(phase2)
        const interference = mirror1.mul(mirror2)
        const color = vec3(interference)
        return vec4(color, 1)
}`}
/>

## Technical Implementation Details

### Anti-Aliasing Strategy

The function employs derivative-based anti-aliasing that:

- Calculates spatial frequency using screen-space derivatives
- Applies Nyquist filtering to prevent aliasing artifacts
- Maintains visual quality across different zoom levels
- Automatically adjusts smoothing based on viewing distance

### Performance Characteristics

| Aspect                 | Specification                        |
| ---------------------- | ------------------------------------ |
| **Computational Cost** | Low - uses built-in derivatives      |
| **Memory Usage**       | Minimal - no texture lookups         |
| **Scalability**        | Excellent - constant time complexity |
| **Quality**            | High - automatic anti-aliasing       |
