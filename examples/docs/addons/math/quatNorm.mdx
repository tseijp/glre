---
title: 'quatNorm'
description: 'Quaternion normalization for unit length rotation preservation'
keywords: ['quaternion', 'normalization', 'unit quaternion', 'rotation', 'magnitude']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# quatNorm: Quaternion Normalization Operations

### Unit Quaternion Enforcement for Pure Rotations

The quatNorm function implements quaternion normalization, converting arbitrary quaternions to unit quaternions with magnitude 1. This operation preserves rotational direction while eliminating scaling components, ensuring that quaternions represent pure rotations without distortion.

**Mathematical Definition:**

For quaternion $q = (x, y, z, w)$ with magnitude $|q| = \sqrt{x^2 + y^2 + z^2 + w^2}$:

$$
\text{quatNorm}(q) = \frac{q}{|q|} = \frac{(x, y, z, w)}{\sqrt{x^2 + y^2 + z^2 + w^2}}
$$

**Properties:**
- Preserves rotation axis and angle relationships
- Eliminates scaling artifacts from quaternion operations
- Essential for maintaining rotational validity after arithmetic
- Required for proper interpolation and composition

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const coords = uv.sub(0.5).mul(6)
        const gridPos = coords.floor()
        const local = coords.fract().sub(0.5)
        
        const hash = sin(gridPos.x.mul(73.1).add(gridPos.y.mul(157.3))).mul(43758.5).fract()
        const scale = hash.mul(2).add(0.5)
        
        const angle = iTime.mul(0.4).add(hash.mul(6.28))
        const unnormalized = vec4(sin(angle).mul(scale), cos(angle.mul(1.2)).mul(scale), sin(angle.mul(0.7)), cos(angle).mul(scale.mul(0.8)))
        
        const normalized = quatNorm(unnormalized)
        const transform = quat2mat3(normalized)
        const rotated = transform.mul(vec3(local, hash.sub(0.5)))
        
        const pattern = sin(rotated.x.mul(4)).mul(cos(rotated.y.mul(4)))
        const field = pattern.mul(rotated.z.add(1))
        const color = vec3(field.abs(), field.abs().mul(0.8), field.abs().mul(0.6))
        
        return vec4(color, 1)
}`}
/>

### Magnitude Stabilization Under Accumulation

This example demonstrates how quatNorm prevents magnitude drift during iterative quaternion operations. Without normalization, repeated multiplications cause exponential magnitude growth, while normalization maintains stable unit quaternions.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const t = iTime.mul(0.2)
        const cellPos = uv.mul(5)
        const cell = cellPos.floor()
        const local = cellPos.fract().sub(0.5)
        
        const seed = sin(cell.x.mul(127.1).add(cell.y.mul(311.7))).mul(43758.5).fract()
        const iterations = seed.mul(8).floor().add(1)
        
        const baseQ = vec4(sin(t), cos(t.mul(1.1)), sin(t.mul(0.8)), cos(t)).normalize()
        const deltaQ = vec4(sin(seed.mul(6.28)).mul(0.1), cos(seed.mul(4.15)).mul(0.1), sin(seed.mul(2.71)).mul(0.1), float(1))
        
        let accumulated = baseQ.toVar()
        Loop(iterations, ({ i }) => {
                accumulated.assign(quatMul(accumulated, deltaQ))
                const shouldNormalize = i.mod(2).equal(0)
                accumulated.assign(quatNorm(accumulated).select(accumulated, shouldNormalize))
        })
        
        const finalTransform = quat2mat3(accumulated)
        const rotated = finalTransform.mul(vec3(local, seed))
        
        const magnitude = accumulated.length()
        const stabilityField = magnitude.sub(1).abs().mul(20)
        const color = vec3(stabilityField, float(1).sub(stabilityField), stabilityField.mul(0.5))
        
        return vec4(color, 1)
}`}
/>

The quatNorm function provides essential quaternion maintenance operations for preserving rotational validity, preventing magnitude drift, and ensuring proper mathematical behavior in rotational systems.