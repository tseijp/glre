---
title: 'atan2'
description: 'Calculate the angle between a point and the positive x-axis with proper quadrant handling and normalization to [0, 2π) range'
keywords: ['atan2', 'arctangent', 'angle', 'polar coordinates', 'quadrant', 'direction', 'rotation', 'phase']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# Atan2: Two-Argument Arctangent Function

### Mathematical Foundation

The atan2 function calculates the angle θ between a point (x, y) and the positive x-axis. Unlike the standard arctangent function, atan2 handles all four quadrants correctly and returns values in the range [0, 2π). This normalization makes it perfect for creating smooth angular animations and rotational effects.

$$\text{atan2}(y, x) = \left(\arctan\left(\frac{y}{x}\right) + \pi\right) \bmod 2\pi$$

Where:

- $y$ is the vertical displacement from the reference point
- $x$ is the horizontal displacement from the reference point
- The result $\theta \in [0, 2\pi)$ represents the counter-clockwise angle from the positive x-axis

The function's quadrant-aware implementation ensures continuity across all angular positions:

$$
\theta = \begin{cases}
\arctan\left(\frac{y}{x}\right) + \pi & \text{if } x \geq 0 \\
\arctan\left(\frac{y}{x}\right) + 2\pi & \text{if } x < 0, y \geq 0 \\
\arctan\left(\frac{y}{x}\right) + \pi & \text{if } x < 0, y < 0
\end{cases}
$$

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const pos = uv.sub(center)
        const angle = pos.y.atan2(pos.x)
        const normalizedAngle = angle.div(6.28318530718) // TAU
        return vec4(vec3(normalizedAngle), 1)
}`}
/>

### Polar Coordinate System

Atan2 serves as the fundamental building block for polar coordinate systems. By combining it with the distance function, you can convert Cartesian coordinates to polar coordinates, enabling radial patterns and rotational transformations.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const pos = uv.sub(center)
        const angle = pos.y.atan2(pos.x)
        const radius = pos.length()

        const polarPattern = angle.mul(8).sin().mul(radius.mul(20).cos())
        return vec4(vec3(polarPattern.mul(0.5).add(0.5)), 1)

}`}
/>

### Spiral Generator

The atan2 function excels at creating spiral patterns by combining angular and radial components. This technique produces hypnotic, organic-looking visuals that spiral outward from the center.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const pos = uv.sub(center)
        const angle = pos.y.atan2(pos.x)
        const radius = pos.length()

        const spiralAngle = angle.add(radius.mul(20))
        const spiral = spiralAngle.sin().mul(0.5).add(0.5)
        const fadeOut = smoothstep(0.5, 0.0, radius)

        return vec4(vec3(spiral.mul(fadeOut)), 1)

}`}
/>

### Clock Face Visualization

Atan2 naturally creates clock-like visualizations by dividing the angular space into segments. This example demonstrates how to create precise angular divisions for creating clock faces, pie charts, or segmented displays.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const pos = uv.sub(center)
        const angle = pos.y.atan2(pos.x)
        const radius = pos.length()

        // Create 12 hour segments like a clock
        const hour = angle.div(6.28318530718).mul(12).floor()
        const hourColor = hour.div(12)

        // Add radial lines
        const radialLines = step(0.95, angle.mul(12).cos().abs())
        const circularMask = smoothstep(0.45, 0.4, radius)

        return vec4(vec3(hourColor.add(radialLines).mul(circularMask)), 1)

}`}
/>

### Technical Implementation

The atan2 function wraps the standard arctangent calculation with proper quadrant handling. It adds π to shift the range from [-π, π] to [0, 2π], then applies modulo 2π to ensure the result stays within bounds. This normalization creates smooth, continuous angular values perfect for visual effects.

| Parameter | Description                                  | Range           |
| --------- | -------------------------------------------- | --------------- |
| y         | Vertical displacement from reference point   | Any real number |
| x         | Horizontal displacement from reference point | Any real number |
| Return    | Normalized angle in radians                  | [0, 2π)         |

The function handles edge cases gracefully, including when x approaches zero, maintaining mathematical stability across all quadrants.
