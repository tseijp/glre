---
title: 'atan2'
description: 'Calculate the angle between a point and the positive x-axis with proper quadrant handling and normalization to [0, 2π) range'
keywords: ['atan2', 'arctangent', 'angle', 'polar coordinates', 'quadrant', 'direction', 'rotation', 'phase']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# Atan2: Two-Argument Arctangent Function

### Mathematical Foundation

The atan2 function calculates the angle θ between a point (x, y) and the positive x-axis. Unlike the standard arctangent function, atan2 handles all four quadrants correctly and returns values in the range [0, 2π). This normalization makes it perfect for creating smooth angular animations and rotational effects.

$$\text{atan2}(y, x) = \left(\arctan\left(\frac{y}{x}\right) + \pi\right) \bmod 2\pi$$

Where:

- $y$ is the vertical displacement from the reference point
- $x$ is the horizontal displacement from the reference point
- The result $\theta \in [0, 2\pi)$ represents the counter-clockwise angle from the positive x-axis

The function's quadrant-aware implementation ensures continuity across all angular positions:

$$
\theta = \begin{cases}
\arctan\left(\frac{y}{x}\right) + \pi & \text{if } x \geq 0 \\
\arctan\left(\frac{y}{x}\right) + 2\pi & \text{if } x < 0, y \geq 0 \\
\arctan\left(\frac{y}{x}\right) + \pi & \text{if } x < 0, y < 0
\end{cases}
$$

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const pos = uv.sub(center)
        const angle = atan2(pos.y, pos.x)
        const normalizedAngle = angle.div(6.28318530718) // TAU
        return vec4(vec3(normalizedAngle), 1)
}`}
/>

### Polar Coordinate System

Atan2 serves as the fundamental building block for polar coordinate systems. By combining it with the distance function, you can convert Cartesian coordinates to polar coordinates, enabling radial patterns and rotational transformations.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const pos = uv.sub(center)
        const angle = atan2(pos.y, pos.x)
        const radius = length(pos)

        const polarPattern = sin(angle.mul(8)).mul(cos(radius.mul(20)))
        return vec4(vec3(polarPattern.mul(0.5).add(0.5)), 1)

}`}
/>

### Spiral Generator

The atan2 function excels at creating spiral patterns by combining angular and radial components. This technique produces hypnotic, organic-looking visuals that spiral outward from the center.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const pos = uv.sub(center)
        const angle = atan2(pos.y, pos.x)
        const radius = length(pos)

        const spiralAngle = angle.add(radius.mul(20))
        const spiral = sin(spiralAngle).mul(0.5).add(0.5)
        const fadeOut = smoothstep(0.5, 0.0, radius)

        return vec4(vec3(spiral.mul(fadeOut)), 1)

}`}
/>

### Clock Face Visualization

Atan2 naturally creates clock-like visualizations by dividing the angular space into segments. This example demonstrates how to create precise angular divisions for creating clock faces, pie charts, or segmented displays.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const pos = uv.sub(center)
        const angle = atan2(pos.y, pos.x)
        const radius = length(pos)

        // Create 12 hour segments like a clock
        const hour = floor(angle.div(6.28318530718).mul(12))
        const hourColor = hour.div(12)

        // Add radial lines
        const radialLines = step(0.95, cos(angle.mul(12)).abs())
        const circularMask = smoothstep(0.45, 0.4, radius)

        return vec4(vec3(hourColor.add(radialLines).mul(circularMask)), 1)

}`}
/>

### Angular Gradient Effects

The normalized output of atan2 creates smooth angular gradients that rotate around a center point. These gradients serve as the foundation for creating rotational color wheels and angular lighting effects.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const pos = uv.sub(center)
        const angle = atan2(pos.y, pos.x)
        const radius = length(pos)

        // Create HSV color wheel effect
        const hue = angle.div(6.28318530718)
        const saturation = smoothstep(0.1, 0.4, radius)
        const brightness = smoothstep(0.5, 0.2, radius)

        // Simple HSV to RGB approximation
        const c = hue.mul(6)
        const x = float(1).sub(c.sub(floor(c)).mul(2).sub(1).abs())
        const r = select(float(1), x, float(0), c.lessThan(1).or(c.greaterThan(5)))
        const g = select(x, float(1), float(0), c.lessThan(2).and(c.greaterThan(1)).or(c.lessThan(4).and(c.greaterThan(3))))
        const b = select(float(0), x, float(1), c.greaterThan(2).and(c.lessThan(5)))

        const color = vec3(r, g, b).mul(saturation).add(1.sub(saturation)).mul(brightness)
        return vec4(color, 1)

}`}
/>

### Directional Flow Fields

Atan2 enables the creation of directional flow fields by calculating angles between different points. This technique produces dynamic, flowing patterns that suggest movement and direction throughout the visual space.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center1 = vec2(0.3, 0.3)
        const center2 = vec2(0.7, 0.7)

        const toCenter1 = center1.sub(uv)
        const toCenter2 = center2.sub(uv)

        const angle1 = atan2(toCenter1.y, toCenter1.x)
        const angle2 = atan2(toCenter2.y, toCenter2.x)

        const dist1 = length(toCenter1)
        const dist2 = length(toCenter2)

        // Create flow field between two attractors
        const weight = dist2.div(dist1.add(dist2))
        const flowAngle = mix(angle1, angle2, weight)

        const flowStrength = sin(flowAngle.mul(4)).mul(cos(flowAngle.mul(3)))
        return vec4(vec3(flowStrength.mul(0.5).add(0.5)), 1)

}`}
/>

### Technical Implementation

The atan2 function wraps the standard arctangent calculation with proper quadrant handling. It adds π to shift the range from [-π, π] to [0, 2π], then applies modulo 2π to ensure the result stays within bounds. This normalization creates smooth, continuous angular values perfect for visual effects.

| Parameter | Description                                  | Range           |
| --------- | -------------------------------------------- | --------------- |
| y         | Vertical displacement from reference point   | Any real number |
| x         | Horizontal displacement from reference point | Any real number |
| Return    | Normalized angle in radians                  | [0, 2π)         |

The function handles edge cases gracefully, including when x approaches zero, maintaining mathematical stability across all quadrants.
