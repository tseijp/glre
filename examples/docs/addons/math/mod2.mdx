---
title: 'mod2'
description: 'Cellular space partitioning engine that creates infinite dimensional tessellations through mathematical domain repetition and spatial metamorphosis'
keywords:
        [
                tsl,
                mod2,
                cellular tiling,
                domain repetition,
                spatial tessellation,
                infinite space,
                dimensional partitioning,
                mathematical cells,
        ]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# mod2: Infinite Cellular Space Architect

### Mathematical Domain Repetition Through Dimensional Tessellation

The mod2 function performs cellular space partitioning by creating infinite tessellations of mathematical domains. This operation divides continuous space into discrete cellular regions while maintaining spatial coherence through calculated domain repetition, enabling the construction of infinite architectural patterns from finite mathematical definitions.

The mathematical foundation reveals cellular transformation:

$$
mod2(p, s) = \begin{cases}
c = \lfloor \frac{p + \frac{s}{2}}{s} \rfloor \text{ (cell coordinates)} \\
p' = ((p + \frac{s}{2}) \bmod s) - \frac{s}{2} \text{ (wrapped position)}
\end{cases}
$$

Where $p$ represents the spatial coordinate, $s$ defines the cellular dimensions, $c$ identifies the discrete cell location, and $p'$ provides the relative position within each cell, creating mathematical correspondence between infinite space and finite cellular domains.

<FragmentEditor
        code={`
const fragment = () => {
        const cellSize = iTime.mul(0.3).sin().mul(0.15).add(0.25)
        const spatialCoord = uv.sub(0.5).mul(6)
        const domainData = mod2(spatialCoord, cellSize)
        const cellCoords = domainData.xy
        const localPos = domainData.zw
        const cellIndex = cellCoords.x.add(cellCoords.y.mul(100))
        const cellPhase = cellIndex.mul(0.7).sin().mul(PI)
        const morphingRadius = cellPhase.add(iTime.mul(2)).cos().mul(0.5).add(0.5).mul(0.4)
        const cellularField = localPos.length().sub(morphingRadius)
        const energyDistribution = smoothstep(0.02, -0.02, cellularField)
        const resonanceField = smoothstep(0.15, 0, cellularField.abs()).pow(2).mul(0.8)
        return vec4(energyDistribution.add(resonanceField).mul(0.9), energyDistribution.mul(1.3), energyDistribution.add(resonanceField).mul(0.7), 1)
}`}
/>
