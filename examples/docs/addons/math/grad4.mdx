---
title: 'grad4'
description: 'Generate pseudo-random 4D gradient vectors for noise functions with precise mathematical distribution'
keywords: [noise, gradient, 4d, procedural, randomness, perlin]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# 4D Gradient Vector Generation

### Mathematical Foundation: 4D Gradient Vector Generation

The grad4 function generates pseudo-random 4D gradient vectors using deterministic mathematical operations to ensure consistent spatial coherence in noise algorithms.

**Mathematical Definition:**

$$
\begin{align}
\mathbf{p}_{xyz} &= \lfloor \text{frac}(j \cdot \mathbf{ip}_{xyz}) \cdot 7 \rfloor \cdot ip_z - 1 \\
p_w &= 1.5 - |\mathbf{p}_{xyz}| \cdot \mathbf{1}_{xyz} \\
\mathbf{s} &= \text{lessThan}(\mathbf{p}, \mathbf{0}) \\
\mathbf{p}_{xyz} &= \mathbf{p}_{xyz} + (\mathbf{s}_{xyz} \cdot 2 - 1) \cdot s_w
\end{align}
$$

**Algorithm Components:**
- $j$: Scalar seed value for deterministic generation
- $\mathbf{ip} = (ip_x, ip_y, ip_z, ip_w)$: Parameter vector controlling distribution
- $\mathbf{p}$: Resulting 4D gradient vector
- $\mathbf{s}$: Sign correction vector for proper gradient distribution

**Properties:**
- Deterministic generation ensures spatial coherence
- Vectors maintain unit-sphere distribution characteristics  
- Consistent mathematical relationships between neighboring coordinates
- Optimal for Perlin noise and procedural texture generation

### Mathematical Beauty in Four Dimensions

This function forms the mathematical foundation for advanced procedural generation techniques, enabling the creation of organic textures, terrain features, and fluid simulations through controlled randomness.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const pos = uv.mul(8.0)
        const j = pos.x.add(pos.y.mul(47.0))
        const ip = vec4(0.1, 0.2, 7.0, 1.0)

        const grad = grad4(j, ip)
        const colorPattern = grad.xyz.abs()

        return vec4(colorPattern, 1)

}`}
/>

### Dimensional Cascade Visualization

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const pos = uv.mul(12.0)
        const time = iTime.mul(0.3)

        const gradients = pos.x.add(pos.y.mul(31.0)).add(time)
        const params = vec4(0.15, 0.25, 6.5, 0.8)

        const g1 = grad4(gradients, params)
        const g2 = grad4(gradients.add(100.0), params.mul(1.3))
        const g3 = grad4(gradients.add(200.0), params.mul(0.7))

        const blend = g1.xyz.mul(0.5).add(g2.xyz.mul(0.3)).add(g3.xyz.mul(0.2))
        const intensity = blend.length().mul(2.0)

        return vec4(blend.abs().mul(intensity), 1)

}`}
/>

### Noise Field Symphony

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const coord = uv.mul(20.0)
        const oscillation = iTime.mul(0.5)

        const base = coord.x.mul(13.0).add(coord.y.mul(71.0)).add(oscillation.mul(23.0))
        const params = vec4(0.08, 0.12, 8.0, 1.2)

        const field1 = grad4(base, params)
        const field2 = grad4(base.add(500.0), params.mul(vec4(1.5, 0.8, 0.9, 1.1)))
        const field3 = grad4(base.add(1000.0), params.mul(vec4(0.6, 1.4, 1.1, 0.9)))

        const combined = field1.xyz.add(field2.xyz.mul(0.6)).add(field3.xyz.mul(0.4))
        const normalized = combined.normalize().mul(0.5).add(0.5)

        const pulse = sin(combined.length().mul(10.0).add(oscillation.mul(2.0))).mul(0.3).add(0.7)

        return vec4(normalized.mul(pulse), 1)

}`}
/>
