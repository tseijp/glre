---
title: 'grad4'
description: 'Generate pseudo-random 4D gradient vectors for noise functions with precise mathematical distribution'
keywords: [noise, gradient, 4d, procedural, randomness, perlin]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# 4D Gradient Vector Generation

### Mathematical Foundation: 4D Gradient Vector Generation

The grad4 function generates pseudo-random 4D gradient vectors using deterministic mathematical operations to ensure consistent spatial coherence in noise algorithms.

**Mathematical Definition:**

$$
\begin{align}
\mathbf{p}_{xyz} &= \lfloor \text{frac}(j \cdot \mathbf{ip}_{xyz}) \cdot 7 \rfloor \cdot ip_z - 1 \\
p_w &= 1.5 - |\mathbf{p}_{xyz}| \cdot \mathbf{1}_{xyz} \\
\mathbf{s} &= \text{lessThan}(\mathbf{p}, \mathbf{0}) \\
\mathbf{p}_{xyz} &= \mathbf{p}_{xyz} + (\mathbf{s}_{xyz} \cdot 2 - 1) \cdot s_w
\end{align}
$$

**Algorithm Components:**

- $j$: Scalar seed value for deterministic generation
- $\mathbf{ip} = (ip_x, ip_y, ip_z, ip_w)$: Parameter vector controlling distribution
- $\mathbf{p}$: Resulting 4D gradient vector
- $\mathbf{s}$: Sign correction vector for proper gradient distribution

**Properties:**

- Deterministic generation ensures spatial coherence
- Vectors maintain unit-sphere distribution characteristics
- Consistent mathematical relationships between neighboring coordinates
- Optimal for Perlin noise and procedural texture generation

### Multiple Gradient Fields

<FragmentEditor
        code={`
const fragment = () => {
        const coord = uv.mul(20)
        const oscillation = iTime.mul(0.5)

        const base = coord.x.mul(13.0).add(coord.y.mul(71.0)).add(oscillation.mul(23.0))
        const params = vec4(0.08, 0.12, 8.0, 1.2)

        const field1 = grad4(base, params)
        const field2 = grad4(base.add(500.0), params.mul(vec4(1.5, 0.8, 0.9, 1.1)))
        const field3 = grad4(base.add(1000.0), params.mul(vec4(0.6, 1.4, 1.1, 0.9)))

        const combined = field1.xyz.add(field2.xyz.mul(0.6)).add(field3.xyz.mul(0.4))
        const normalized = combined.normalize().mul(0.5).add(0.5)

        const pulse = combined.length().mul(10).add(oscillation.mul(2)).sin().mul(0.3).add(0.7)

        return vec4(normalized.mul(pulse), 1)

}`}
/>
