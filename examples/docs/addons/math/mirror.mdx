---
title: 'mirror'
description: 'Continuous periodic mirroring function creating alternating directional flow patterns'
keywords: ['mirror', 'reflection', 'periodic', 'alternating', 'sawtooth', 'mathematical', 'wave']
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# mirror: Alternating Directional Flow Generator

### Mathematical Reflection Through Alternating Periodic Domains

The mirror function creates alternating directional flow by reflecting every other unit interval, generating continuous periodic patterns where adjacent domains exhibit opposite directional behavior. This mathematical transformation produces visual effects where motion and patterns reverse direction at regular intervals.

The mirror function operates through mathematical reflection where the domain $[0,1) \cup [2,3) \cup [4,5) \cup \ldots$ maintains ascending fractional progression, while intervals $[1,2) \cup [3,4) \cup [5,6) \cup \ldots$ exhibit descending behavior.

Mathematical Definition:

$$
\text{mirror}(x) = f + m - fm \cdot 2
$$

where:

- $f = \text{fract}(x)$ represents the fractional component
- $m = \lfloor \bmod(x, 2) \rfloor$ creates alternating $\{0,1\}$ pattern
- The term $fm \cdot 2$ generates the reflection mechanism

The alternating behavior emerges from the multiplicative interaction between fractional and modular components, creating mathematical domains where:

$$
\text{mirror}(x) = \begin{cases}
\text{fract}(x) & \text{if } \lfloor x \rfloor \text{ is even} \\
1 - \text{fract}(x) & \text{if } \lfloor x \rfloor \text{ is odd}
\end{cases}
$$

This mathematical structure enables creation of complex visual phenomena through simple periodic alternation, where spatial or temporal domains exhibit contrasting directional characteristics while maintaining mathematical continuity.

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const time = iTime.mul(0.7)
        const coord = uv.mul(8).add(time)

        const mirroredX = mirror(coord.x)
        const mirroredY = mirror(coord.y.add(time.mul(0.3)))

        const wave1 = mirroredX.mul(3.14159).sin()
        const wave2 = mirroredY.mul(2.71828).cos()

        const interference = wave1.mul(wave2).abs()

        const phase = coord.x.add(coord.y).mul(0.5)
        const colorPhase = mirror(phase.add(time.mul(0.2)))

        const red = interference.mul(colorPhase.pow(1.5))
        const green = interference.mul(colorPhase.sub(0.33).abs().pow(0.8))
        const blue = interference.mul(colorPhase.sub(0.66).abs().pow(2.0))

        return vec4(red, green, blue, 1)

}`}
/>
