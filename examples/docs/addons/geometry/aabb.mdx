---
title: 'aabb'
description: 'Axis-Aligned Bounding Box computational geometry functions'
keywords: [geometry, bounding box, collision detection, ray intersection, spatial analysis]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# aabb: Axis-Aligned Bounding Box Operations

### Computational Geometry for Spatial Analysis

An Axis-Aligned Bounding Box (AABB) is the smallest rectangular box aligned with coordinate axes that completely encloses a geometric object. AABB functions enable efficient spatial queries and collision detection in graphics applications.

## Mathematical Foundation

An AABB is defined by two 3D points:

$$
\text{AABB} = \{(x, y, z) : \min_x \leq x \leq \max_x, \min_y \leq y \leq \max_y, \min_z \leq z \leq \max_z\}
$$

where $(\min_x, \min_y, \min_z)$ and $(\max_x, \max_y, \max_z)$ represent the minimum and maximum corners.

## Function Reference

| Function | Description | Mathematical Definition | Use Case |
|----------|-------------|------------------------|----------|
| `aabbCentroid` | Calculates box center | $c = \frac{\min + \max}{2}$ | Object positioning |
| `aabbContain` | Point containment test | $p \in [p_{\min}, p_{\max}]$ | Collision detection |
| `aabbDiagonal` | Box dimensions | $d = |\max - \min|$ | Size calculation |
| `aabbExpandFloat` | Uniform expansion | $\min' = \min - v, \max' = \max + v$ | Padding operations |
| `aabbExpandVec3` | Point inclusion | $\min' = \min(p, \min), \max' = \max(p, \max)$ | Dynamic bounds |
| `aabbIntersectRay` | Ray intersection | $t = \frac{\min - \text{origin}}{\text{direction}}$ | Ray casting |
| `aabbSquare` | Box cubification | Equal dimensions from center | Shape normalization |

## Ray-Box Intersection Algorithm

The ray-box intersection uses the slab method. For each axis $i$:

$$
t_{1i} = \frac{\min_i - \text{origin}_i}{\text{direction}_i}
$$

$$
t_{2i} = \frac{\max_i - \text{origin}_i}{\text{direction}_i}
$$

The intersection occurs when:

$$
t_{\text{near}} = \max(\min(t_{1i}, t_{2i})) \leq t_{\text{far}} = \min(\max(t_{1i}, t_{2i}))
$$

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const center = vec2(0.5)
        const size = vec2(0.3)
        const boxMin = center.sub(size.mul(0.5))
        const boxMax = center.add(size.mul(0.5))
        
        const isInside = aabbContain(vec3(boxMin, 0), vec3(boxMax, 0), vec3(uv, 0)).x
        const color = isInside.select(vec3(0.2, 0.8, 0.4), vec3(0.1))
        
        return vec4(color, 1)
}`}
/>

## Point Containment Test

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const mouseNorm = iMouse.div(iResolution)
        const boxCenter = vec2(0.5)
        const boxSize = vec2(0.2)
        
        const boxMin = boxCenter.sub(boxSize)
        const boxMax = boxCenter.add(boxSize)
        
        const contains = aabbContain(vec3(boxMin, 0), vec3(boxMax, 0), vec3(mouseNorm, 0)).x
        const boxColor = contains.select(vec3(1, 0.3, 0.3), vec3(0.3, 0.3, 1))
        
        const inBox = all(uv.greaterThanEqual(boxMin)).and(all(uv.lessThanEqual(boxMax)))
        const finalColor = inBox.select(boxColor, vec3(0.1))
        
        return vec4(finalColor, 1)
}`}
/>