---
title: 'signedDistance'
description: 'Calculate signed distance from point to triangle with inside/outside classification'
keywords: [geometry, triangle, signed-distance, closest-point, orientation]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# triangleSignedDistance: Oriented Distance Field Calculation

### Signed Distance Function for Triangle Surfaces

The triangle signed distance function computes the shortest distance from a point to a triangle surface with orientation information. Positive values indicate points outside the triangle surface, negative values indicate points inside or behind the surface.

The algorithm combines closest point calculation with normal-based orientation testing:

**Distance Calculation Process**

1. **Closest Point Determination**: Find the nearest point on the triangle surface using barycentric coordinate projection
2. **Distance Vector**: Compute $\vec{\delta} = P - P_{\text{closest}}$
3. **Distance Magnitude**: Calculate $d = \|\vec{\delta}\|$
4. **Orientation Testing**: Determine side using $\text{sign}(\vec{\delta} \cdot \vec{n})$

The complete signed distance formula:

$$d_{\text{signed}} = d \cdot \text{sign}\left(\frac{\vec{\delta}}{\|\vec{\delta}\|} \cdot \vec{n}\right)$$

where $\vec{n}$ represents the triangle normal vector.

**Sign Convention**

The sign indicates spatial relationship relative to the triangle plane:

- **Positive**: Point lies on the normal-facing side (outside)
- **Negative**: Point lies on the opposite side (inside/behind)
- **Zero**: Point lies exactly on the triangle surface

This convention enables level set operations, CSG modeling, and surface reconstruction where consistent orientation matters.

<FragmentEditor
        code={`
const fragment = () => {
        const t = iTime.mul(0.4)
        const p = uv.mul(6).sub(3)
        const v1 = vec3(sin(t).mul(2.2), cos(t.mul(1.1)).mul(1.8).sub(0.3), sin(t.mul(0.5)).mul(0.5))
        const v2 = vec3(cos(t.mul(0.9)).mul(2.4), sin(t.mul(1.3)).mul(1.5).add(0.7), cos(t.mul(0.7)).mul(0.6))
        const v3 = vec3(sin(t.mul(1.2)).mul(1.9).add(0.5), cos(t.mul(0.8)).mul(2.1).sub(0.9), sin(t.mul(1.1)).mul(0.4))
        const pos = vec3(p, 0)
        const sdf = triangleSignedDistance(v1, v2, v3, pos)
        const inside = sdf.lessThan(0)
        const field = abs(sdf).saturate()
        const bands = sin(sdf.mul(12)).mul(0.5).add(0.5)
        const color = vec3(0.9, 0.4, 0.2).select(vec3(0.2, 0.6, 0.9), inside)
        return vec4(color.mul(field).add(bands.mul(0.3)), 1)
}`}
/>