---
title: 'distanceSq'
description: 'Calculate squared distance from point to triangle using edge projection and plane distance'
keywords: [geometry, triangle, distance, edge-projection, closest-point]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# triangleDistanceSq: Point-to-Triangle Distance Calculation

### Hybrid Distance Computation Using Edge and Plane Methods

The triangle distance function computes the shortest squared distance from a point to a triangle surface using a hybrid approach combining edge projection and plane distance calculations.

The algorithm determines point classification relative to the triangle using cross product sign testing:

$$
\text{signs} = \text{sign}(\vec{v_{21}} \times \vec{n} \cdot \vec{p_1}) + \text{sign}(\vec{v_{32}} \times \vec{n} \cdot \vec{p_2}) + \text{sign}(\vec{v_{13}} \times \vec{n} \cdot \vec{p_3})
$$

Where $\vec{n} = \vec{v_{21}} \times \vec{v_{13}}$ represents the triangle normal vector.

**Edge Distance Calculation**

For points outside the triangle ($\text{signs} < 2$), distance is computed using edge projections:

$$d_{\text{edge}} = \min\left(\left\|\vec{v_{21}} \cdot \text{saturate}\left(\frac{\vec{v_{21}} \cdot \vec{p_1}}{\|\vec{v_{21}}\|^2}\right) - \vec{p_1}\right\|^2, \ldots\right)$$

The saturate function clamps projection parameters to $[0,1]$, ensuring closest points lie within edge segments.

**Plane Distance Calculation**

For points inside the triangle projection ($\text{signs} \geq 2$), distance uses perpendicular plane distance:

$$d_{\text{plane}} = \frac{(\vec{n} \cdot \vec{p_1})^2}{\|\vec{n}\|^2}$$

This computes the squared perpendicular distance from the point to the triangle plane.

<FragmentEditor
        code={`
const fragment = () => {
        const t = iTime.mul(0.5)
        const p = uv.mul(6).sub(3)
        const v1 = vec3(sin(t).mul(2), cos(t.mul(1.2)).mul(1.5).sub(0.5), 0)
        const v2 = vec3(cos(t.mul(0.8)).mul(2.2), sin(t.mul(1.1)).mul(1.2).add(0.8), 0)
        const v3 = vec3(sin(t.mul(1.3)).mul(1.8).add(0.3), cos(t.mul(0.9)).mul(1.8).sub(1), 0)
        const pos = vec3(p, 0)
        const dist = triangleDistanceSq(v1, v2, v3, pos)
        const field = smoothstep(0.1, 0.3, sqrt(dist)).oneMinus()
        const grad = fract(sqrt(dist).mul(8))
        return vec4(field.mul(0.2).add(grad.mul(0.8)), field.mul(0.4).add(0.3), field.mul(0.6).add(0.2), 1)
}`}
/>