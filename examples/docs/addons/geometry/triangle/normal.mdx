---
title: 'normal'
description: 'Calculate normalized surface normal vector for triangle using cross product'
keywords: [geometry, triangle, normal, cross-product, surface-orientation]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# triangleNormal: Surface Normal Vector Calculation

### Cross Product Method for Triangle Orientation

The triangle normal function computes the normalized surface normal vector using the cross product of two edge vectors. This fundamental operation determines triangle orientation and enables lighting calculations, backface culling, and surface analysis.

Given triangle vertices $A$, $B$, and $C$, the function calculates edge vectors:

$$
\begin{align}
\vec{e_1} &= B - A \\
\vec{e_2} &= C - A
\end{align}
$$

The cross product generates a vector perpendicular to the triangle plane:

$$\vec{n_{raw}} = \vec{e_1} \times \vec{e_2}$$

The magnitude of this cross product equals twice the triangle area. Normalization produces a unit vector indicating surface orientation:

$$\vec{n} = \frac{\vec{e_1} \times \vec{e_2}}{\|\vec{e_1} \times \vec{e_2}\|}$$

**Winding Order Significance**

The normal direction depends on vertex winding order. Counter-clockwise winding (when viewed from outside) produces outward-facing normals, while clockwise winding generates inward-facing normals. This property enables consistent surface orientation across mesh structures.

The right-hand rule determines normal direction: fingers curl from first edge to second edge, thumb points in normal direction.

<FragmentEditor
        code={`
const fragment = () => {
        const t = iTime.mul(0.6)
        const p = uv.mul(4).sub(2)
        const v1 = vec3(sin(t).mul(1.5), cos(t.mul(1.2)).mul(1.2).sub(0.5), 0)
        const v2 = vec3(cos(t.mul(0.9)).mul(1.8), sin(t.mul(1.1)).mul(0.9).add(0.6), 0)
        const v3 = vec3(sin(t.mul(1.3)).mul(1.1).add(0.4), cos(t.mul(0.8)).mul(1.6).sub(0.8), 0)
        const n = triangleNormal(v1, v2, v3)
        const light = vec3(0, 0, 1)
        const intensity = dot(n, light).saturate()
        const edge = length(p.sub(v1.xy)).min(length(p.sub(v2.xy))).min(length(p.sub(v3.xy)))
        const wire = smoothstep(0.02, 0.04, edge).oneMinus()
        const color = intensity.mul(vec3(0.8, 0.6, 0.4)).add(wire.mul(0.3))
        return vec4(color, 1)
}`}
/>