---
title: 'centroid'
description: 'Calculate the geometric center point of a triangle'
keywords: [geometry, triangle, centroid, center, geometric-mean]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# centroid: Triangle Geometric Center Calculation

### Arithmetic Mean Method for Triangle Center Point

The triangle centroid function computes the geometric center of a triangle by calculating the arithmetic mean of its three vertices. This fundamental operation determines the balance point where the triangle would rest if made of uniform material.

Given triangle vertices $A$, $B$, and $C$, the centroid formula is:

$$\text{Centroid} = \frac{A + B + C}{3}$$

This simple averaging operation produces the point equidistant from all three vertices in terms of their vector sum. The centroid divides each median line (line from vertex to opposite edge midpoint) in a 2:1 ratio.

**Geometric Properties**

The centroid represents the triangle's center of mass for uniform density distribution. It lies inside the triangle for all non-degenerate triangles and maintains consistent relationships with other triangle features:

- Distance from centroid to any vertex equals $\frac{2}{3}$ of the corresponding median length
- The centroid remains invariant under translation and scales proportionally under uniform scaling
- Three lines connecting each vertex to the opposite edge midpoint intersect at the centroid

<FragmentEditor
        code={`
const fragment = () => {
        const t = iTime.mul(0.8)
        const v1 = vec3(sin(t).mul(1.5), cos(t.mul(1.2)).mul(1.2), 0)
        const v2 = vec3(cos(t.mul(0.9)).mul(1.8), sin(t.mul(1.1)).mul(0.9), 0)
        const v3 = vec3(sin(t.mul(1.3)).mul(1.1), cos(t.mul(0.8)).mul(1.6), 0)
        const center = centroid(v1, v2, v3)
        const p = uv.mul(4).sub(2)
        const distToCenter = length(p.sub(center.xy))
        const pulse = sin(distToCenter.mul(8).sub(iTime.mul(4))).mul(0.5).add(0.5)
        const edge = min(min(length(p.sub(v1.xy)), length(p.sub(v2.xy))), length(p.sub(v3.xy)))
        const vertices = smoothstep(0.1, 0.15, edge).oneMinus()
        return vec4(pulse.mul(0.7), vertices.add(pulse.mul(0.5)), pulse.mul(0.3).add(vertices), 1)
}`}
/>