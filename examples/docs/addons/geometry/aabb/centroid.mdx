---
title: 'centroid'
description: 'Calculate the center point of an axis-aligned bounding box'
keywords: [geometry, aabb, centroid, center, midpoint]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# aabbCentroid: Bounding Box Center Calculation

### Midpoint Formula for AABB Center Determination

The AABB centroid function computes the geometric center of an axis-aligned bounding box using the midpoint formula. This operation determines the central point equidistant from all faces of the rectangular volume.

Given an AABB with minimum bounds $\vec{b_{\min}}$ and maximum bounds $\vec{b_{\max}}$, the centroid is calculated as:

$$\text{Centroid} = \frac{\vec{b_{\min}} + \vec{b_{\max}}}{2}$$

This simple averaging operation produces the point at the geometric center of the bounding box. The centroid represents the center of mass for uniform density distribution within the volume.

**Geometric Applications**

The AABB centroid serves multiple computational purposes:

- **Spatial Partitioning**: Center point for octree and BSP tree subdivisions
- **Collision Detection**: Reference point for broad-phase collision algorithms
- **Level of Detail**: Distance calculations for LOD switching based on viewer proximity
- **Frustum Culling**: Representative point for visibility testing

<FragmentEditor
        code={`
const fragment = () => Scope(() => {
        const t = iTime.mul(0.6)
        const box = AABB({
                minBounds: vec3(t.sin().mul(1.2).sub(0.8), t.mul(1.3).cos().mul(0.9).sub(0.5), 0),
                maxBounds: vec3(t.mul(0.8).sin().mul(1.1).add(0.6), t.mul(0.7).cos().add(0.7), 0)
        })
        const center = aabbCentroid(box)
        const p = uv.mul(4).sub(2)
        const distToCenter = length(p.sub(center.xy))
        const centerGlow = smoothstep(0.15, 0.05, distToCenter)
        const boxEdge = p.x.sub(box.minBounds.x).abs()
                   .min(p.x.sub(box.maxBounds.x).abs())
                   .min(p.y.sub(box.minBounds.y).abs()
                   .min(p.y.sub(box.maxBounds.y).abs()))
        const wireframe = smoothstep(0.02, 0.04, boxEdge).oneMinus()
        return vec4(centerGlow, wireframe.add(centerGlow.mul(0.8)), centerGlow.mul(0.6).add(wireframe), 1)
})`}
/>
