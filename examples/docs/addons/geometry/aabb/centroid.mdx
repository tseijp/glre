---
title: 'centroid'
description: 'Calculate the center point of an axis-aligned bounding box'
keywords: [geometry, aabb, centroid, center, midpoint]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# aabbCentroid: Bounding Box Center Calculation

### Midpoint Formula for AABB Center Determination

The AABB centroid function computes the geometric center of an axis-aligned bounding box using the midpoint formula. This operation determines the central point equidistant from all faces of the rectangular volume.

Given an AABB with minimum bounds $\vec{b_{\min}}$ and maximum bounds $\vec{b_{\max}}$, the centroid is calculated as:

$$\text{Centroid} = \frac{\vec{b_{\min}} + \vec{b_{\max}}}{2}$$

This simple averaging operation produces the point at the geometric center of the bounding box. The centroid represents the center of mass for uniform density distribution within the volume.

**Geometric Applications**

The AABB centroid serves multiple computational purposes:
- **Spatial Partitioning**: Center point for octree and BSP tree subdivisions
- **Collision Detection**: Reference point for broad-phase collision algorithms
- **Level of Detail**: Distance calculations for LOD switching based on viewer proximity
- **Frustum Culling**: Representative point for visibility testing

<FragmentEditor
        code={`
const fragment = () => {
        const t = iTime.mul(0.6)
        const minBounds = vec3(sin(t).mul(1.2).sub(0.8), cos(t.mul(1.3)).mul(0.9).sub(0.5), 0)
        const maxBounds = vec3(sin(t.mul(0.8)).mul(1.1).add(0.6), cos(t.mul(0.7)).mul(1.0).add(0.7), 0)
        const box = AABB({ minBounds, maxBounds })
        const center = aabbCentroid(box)
        const p = uv.mul(4).sub(2)
        const distToCenter = length(p.sub(center.xy))
        const centerGlow = smoothstep(0.15, 0.05, distToCenter)
        const boxEdge = min(
                min(abs(p.x.sub(box.minBounds.x)), abs(p.x.sub(box.maxBounds.x))),
                min(abs(p.y.sub(box.minBounds.y)), abs(p.y.sub(box.maxBounds.y)))
        )
        const wireframe = smoothstep(0.02, 0.04, boxEdge).oneMinus()
        const pulse = sin(distToCenter.mul(6).sub(iTime.mul(3))).mul(0.5).add(0.5)
        return vec4(centerGlow.add(pulse.mul(0.3)), wireframe.add(centerGlow.mul(0.8)), centerGlow.mul(0.6).add(wireframe), 1)
}`}
/>