---
title: 'intersect'
description: 'Calculate ray-AABB intersection distances for 3D ray tracing'
keywords: [geometry, aabb, intersection, ray-tracing, distance]
date: 2025-08-06
---

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# intersect: AABB Ray Intersection Algorithm

### Slab Method for Efficient Ray-Box Testing

The AABB intersection function implements the slab method for computing ray-box intersection distances. This algorithm determines entry and exit points where a ray intersects the rectangular volume defined by the bounding box.

Given an AABB with bounds $[\vec{b_{\min}}, \vec{b_{\max}}]$, ray origin $\vec{o}$, and ray direction $\vec{d}$, the algorithm computes:

$$
\begin{align}
\vec{t_{\min}} &= \frac{\vec{b_{\min}} - \vec{o}}{\vec{d}} \\
\vec{t_{\max}} &= \frac{\vec{b_{\max}} - \vec{o}}{\vec{d}}
\end{align}
$$

The slab intersections are ordered and combined:

$$
\begin{align}
\vec{t_1} &= \min(\vec{t_{\min}}, \vec{t_{\max}}) \\
\vec{t_2} &= \max(\vec{t_{\min}}, \vec{t_{\max}}) \\
t_{\text{near}} &= \max(t_{1,x}, t_{1,y}, t_{1,z}) \\
t_{\text{far}} &= \min(t_{2,x}, t_{2,y}, t_{2,z})
\end{align}
$$

**Intersection Interpretation**

The returned vec2 contains $(t_{\text{near}}, t_{\text{far}})$ representing:
- **$t_{\text{near}}$**: Distance to entry point (if positive)
- **$t_{\text{far}}$**: Distance to exit point
- **Valid intersection**: $t_{\text{near}} \leq t_{\text{far}}$ and $t_{\text{far}} > 0$

**Applications**

Ray-AABB intersection enables multiple rendering techniques:
- **Ray Tracing**: Primary ray-scene intersection testing
- **Shadow Rays**: Occlusion testing for lighting calculations
- **Frustum Culling**: Camera view volume intersection testing
- **Spatial Traversal**: Octree and grid acceleration structure navigation

<FragmentEditor
        code={`
const fragment = () => {
        const t = iTime.mul(0.4)
        const p = uv.mul(6).sub(3)
        const minBounds = vec3(sin(t).mul(1.2).sub(0.5), cos(t.mul(1.1)).mul(0.9).sub(0.2), -1)
        const maxBounds = vec3(sin(t.mul(0.8)).mul(1.3).add(0.4), cos(t.mul(0.9)).mul(1.0).add(0.6), 1)
        const box = AABB({ minBounds, maxBounds })
        const rayOrigin = vec3(p, -3)
        const rayDir = vec3(sin(iTime.mul(0.3)).mul(0.1), cos(iTime.mul(0.4)).mul(0.1), 1).normalize()
        const intersection = intersect(box, rayOrigin, rayDir)
        const tNear = intersection.x
        const tFar = intersection.y
        const validHit = tNear.lessThanEqual(tFar).and(tFar.greaterThan(0))
        const hitPoint = rayOrigin.add(rayDir.mul(max(tNear, 0)))
        const distToHit = length(p.sub(hitPoint.xy))
        const hitGlow = smoothstep(0.1, 0.05, distToHit).mul(validHit)
        const rayPath = abs(dot(vec2(p.sub(rayOrigin.xy)), vec2(rayDir.xy).normalize().yx.mul(vec2(1, -1))))
        const rayVis = smoothstep(0.02, 0.01, rayPath).mul(0.3)
        const boxEdge = min(
                min(abs(p.x.sub(box.minBounds.x)), abs(p.x.sub(box.maxBounds.x))),
                min(abs(p.y.sub(box.minBounds.y)), abs(p.y.sub(box.maxBounds.y)))
        )
        const wireframe = smoothstep(0.02, 0.04, boxEdge).oneMinus().mul(0.4)
        const color = vec3(0.1, 0.2, 0.4).add(hitGlow.mul(vec3(0.9, 0.6, 0.2))).add(rayVis).add(wireframe)
        return vec4(color, 1)
}`}
/>