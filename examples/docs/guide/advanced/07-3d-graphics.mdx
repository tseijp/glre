# 3D Graphics and Spatial Rendering

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

Learn to create three-dimensional visuals and camera-controlled spatial rendering.

## 3D Space Fundamentals

### Three-Dimensional Coordinate System

GLRE defines three-dimensional space as follows:

```
       Y↑
       |
       |
       |
       0----→ X
      /
     /
    ↙ Z
```

### Basic 3D Objects

```javascript
const gl = createGL({
        count: 36, // Cube rendering requires 36 vertices
        width: 400,
        height: 400,

        vertex: () => {
                const position = attribute('position') // 3D coordinates
                const viewMatrix = uniform('viewMatrix')
                const projectionMatrix = uniform('projectionMatrix')

                // 3D transformation
                const worldPos = position
                const viewPos = viewMatrix.mul(vec4(worldPos, 1))
                const clipPos = projectionMatrix.mul(viewPos)

                return clipPos
        },

        fragment: () => {
                const worldPos = varying('worldPos')

                // Map coordinates to colors
                const color = worldPos

                return vec4(color, 1)
        },
})

// Cube vertex data
const cubeVertices = [
        // Front face
        -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1,
        // Back face
        -1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, -1,
        // Top face
        -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1,
        // Bottom face
        -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, -1, 1, -1, 1, -1, -1, 1,
        // Right face
        1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1,
        // Left face
        -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1,
]

gl.attribute('position', cubeVertices)
```

### Camera and Projection

```javascript
// View matrix calculation
const createViewMatrix = (eye, target, up) => {
        const forward = normalize(target.sub(eye))
        const right = normalize(cross(forward, up))
        const realUp = cross(right, forward)

        return mat4([
                right.x,
                realUp.x,
                -forward.x,
                0,
                right.y,
                realUp.y,
                -forward.y,
                0,
                right.z,
                realUp.z,
                -forward.z,
                0,
                -dot(right, eye),
                -dot(realUp, eye),
                dot(forward, eye),
                1,
        ])
}

// Projection matrix calculation
const createPerspectiveMatrix = (fov, aspect, near, far) => {
        const f = 1 / Math.tan(fov / 2)
        const rangeInv = 1 / (near - far)

        return mat4([
                f / aspect,
                0,
                0,
                0,
                0,
                f,
                0,
                0,
                0,
                0,
                (near + far) * rangeInv,
                -1,
                0,
                0,
                near * far * rangeInv * 2,
                0,
        ])
}

gl('loop', () => {
        const time = performance.now() / 1000

        // Camera position
        const eye = vec3(Math.cos(time) * 5, 3, Math.sin(time) * 5)
        const target = vec3(0, 0, 0)
        const up = vec3(0, 1, 0)

        // Matrix setup
        const viewMatrix = createViewMatrix(eye, target, up)
        const projectionMatrix = createPerspectiveMatrix(
                Math.PI / 4, // 45 degrees
                gl.size[0] / gl.size[1], // Aspect ratio
                0.1, // near
                100 // far
        )

        gl.uniform('viewMatrix', viewMatrix)
        gl.uniform('projectionMatrix', projectionMatrix)
})
```

## Lighting Systems

### Basic Light Source

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const worldPos = varying('worldPos')
        const worldNormal = varying('worldNormal')
        // Light settings
        const lightPos = uniform('lightPosition')
        const lightColor = uniform('lightColor')
        // Lambert reflection
        const lightDir = normalize(lightPos.sub(worldPos))
        const diffuse = max(0, dot(worldNormal, lightDir))
        // Final color
        const baseColor = vec3(0.8, 0.6, 0.4)
        const finalColor = baseColor.mul(lightColor).mul(diffuse)
        return vec4(finalColor, 1)
}`}
/>

```javascript
// Light setup
gl.uniform('lightPosition', [5, 5, 5])
gl.uniform('lightColor', [1, 1, 0.8])
```

### Advanced Lighting (Phong Reflection)

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const worldPos = varying('worldPos')
        const worldNormal = varying('worldNormal')
        const cameraPos = uniform('cameraPosition')
        // Light settings
        const lightPos = uniform('lightPosition')
        const lightColor = uniform('lightColor')
        // Vector calculations
        const lightDir = normalize(lightPos.sub(worldPos))
        const viewDir = normalize(cameraPos.sub(worldPos))
        const reflectDir = reflect(lightDir.negate(), worldNormal)
        // Ambient lighting
        const ambient = vec3(0.1, 0.1, 0.15)
        // Diffuse reflection
        const diffuse = max(0, dot(worldNormal, lightDir)).mul(lightColor)
        // Specular reflection
        const specularPower = 32
        const specular = pow(max(0, dot(viewDir, reflectDir)), specularPower)
                .mul(lightColor)
                .mul(0.5)
        // Final color
        const baseColor = vec3(0.7, 0.5, 0.3)
        const finalColor = baseColor.mul(ambient.add(diffuse)).add(specular)
        return vec4(finalColor, 1)
}`}
/>

### Multiple Light Sources

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const worldPos = varying('worldPos')
        const worldNormal = varying('worldNormal')
        let totalLighting = vec3(0.1, 0.1, 0.15) // Ambient light
        // Three light sources
        const lightPositions = [uniform('light1Position'), uniform('light2Position'), uniform('light3Position')]
        const lightColors = [uniform('light1Color'), uniform('light2Color'), uniform('light3Color')]
        Loop(3, ({ i }) => {
                const lightPos = lightPositions[i]
                const lightColor = lightColors[i]
                const lightDir = normalize(lightPos.sub(worldPos))
                const distance = length(lightPos.sub(worldPos))
                // Distance attenuation
                const attenuation = oneMinus(min(1, distance.div(10)))
                // Diffuse reflection
                const diffuse = max(0, dot(worldNormal, lightDir)).mul(lightColor).mul(attenuation)
                totalLighting.assign(totalLighting.add(diffuse))
        })
        const baseColor = vec3(0.8, 0.6, 0.4)
        const finalColor = baseColor.mul(totalLighting)
        return vec4(finalColor, 1)
}`}
/>

## 3D Object Generation

### Sphere Generation

```javascript
const generateSphere = (radius, segments) => {
        const vertices = []
        const normals = []
        const indices = []

        // Generate vertices and normals
        for (let i = 0; i <= segments; i++) {
                const phi = (i / segments) * Math.PI
                for (let j = 0; j <= segments; j++) {
                        const theta = (j / segments) * 2 * Math.PI

                        const x = radius * Math.sin(phi) * Math.cos(theta)
                        const y = radius * Math.cos(phi)
                        const z = radius * Math.sin(phi) * Math.sin(theta)

                        vertices.push(x, y, z)
                        normals.push(x / radius, y / radius, z / radius)
                }
        }

        // Generate indices
        for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                        const a = i * (segments + 1) + j
                        const b = a + segments + 1

                        indices.push(a, b, a + 1)
                        indices.push(b, b + 1, a + 1)
                }
        }

        return { vertices, normals, indices }
}

const sphere = generateSphere(1, 32)
gl.attribute('position', sphere.vertices)
gl.attribute('normal', sphere.normals)
gl.count = sphere.indices.length
```

### Torus (Donut Shape)

```javascript
const generateTorus = (majorRadius, minorRadius, majorSegments, minorSegments) => {
        const vertices = []
        const normals = []

        for (let i = 0; i <= majorSegments; i++) {
                const u = (i / majorSegments) * 2 * Math.PI

                for (let j = 0; j <= minorSegments; j++) {
                        const v = (j / minorSegments) * 2 * Math.PI

                        const x = (majorRadius + minorRadius * Math.cos(v)) * Math.cos(u)
                        const y = minorRadius * Math.sin(v)
                        const z = (majorRadius + minorRadius * Math.cos(v)) * Math.sin(u)

                        vertices.push(x, y, z)

                        // Normal calculation
                        const nx = Math.cos(v) * Math.cos(u)
                        const ny = Math.sin(v)
                        const nz = Math.cos(v) * Math.sin(u)

                        normals.push(nx, ny, nz)
                }
        }

        return { vertices, normals }
}
```

## Animation Effects

### Rotation Animation

<FragmentEditor
        isFun
        code={`
const vertex = () => {
        const position = attribute('position')
        const time = uniform('iTime')
        // Y-axis rotation
        const rotationY = time.mul(0.5)
        const cosY = cos(rotationY)
        const sinY = sin(rotationY)
        const rotatedPosition = vec3(
                position.x.mul(cosY).add(position.z.mul(sinY)),
                position.y,
                position.x.mul(sinY).sub(position.z.mul(cosY))
        )
        // View and projection transformation
        const mvpMatrix = uniform('mvpMatrix')
        return mvpMatrix.mul(vec4(rotatedPosition, 1))
}
const fragment = () => {
        return vec4(0.8, 0.6, 0.4, 1)
}`}
/>

### Deformation Animation

<FragmentEditor
        isFun
        code={`
const vertex = () => {
        const position = attribute('position')
        const time = uniform('iTime')
        // Wave-based deformation
        const wave = sin(position.y.mul(3).add(time.mul(2))).mul(0.3)
        const deformedPosition = position.add(vec3(wave, 0, 0))
        // Transformation matrix
        const mvpMatrix = uniform('mvpMatrix')
        return mvpMatrix.mul(vec4(deformedPosition, 1))
}
const fragment = () => {
        const worldPos = varying('worldPos')
        // Color change based on deformation
        const colorShift = sin(worldPos.y.mul(5))
        const color = vec3(colorShift, 0.6, oneMinus(colorShift))
        return vec4(color, 1)
}`}
/>

## Spatial Effects

### Fog Effect

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const worldPos = varying('worldPos')
        const cameraPos = uniform('cameraPosition')
        // Object base color
        const objectColor = vec3(0.8, 0.6, 0.4)
        // Fog settings
        const fogColor = vec3(0.7, 0.8, 0.9)
        const fogNear = 5
        const fogFar = 20
        // Distance from camera
        const distance = length(worldPos.sub(cameraPos))
        // Fog density calculation
        const fogFactor = clamp((distance - fogNear) / (fogFar - fogNear), 0, 1)
        // Fog and color blending
        const finalColor = mix(objectColor, fogColor, fogFactor)
        return vec4(finalColor, 1)
}`}
/>

### Depth of Field

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const worldPos = varying('worldPos')
        const cameraPos = uniform('cameraPosition')
        const focusDistance = uniform('focusDistance')
        // Distance from camera
        const distance = length(worldPos.sub(cameraPos))
        // Distance from focus
        const focusBlur = abs(distance - focusDistance) / 3
        const blurAmount = clamp(focusBlur, 0, 1)
        // Base color
        const sharpColor = vec3(0.8, 0.6, 0.4)
        // Blur effect (simplified)
        const blurredColor = sharpColor.mul(0.7).add(0.3)
        const finalColor = mix(sharpColor, blurredColor, blurAmount)
        return vec4(finalColor, 1)
}`}
/>

## Instancing

### Massive Object Rendering

```javascript
const instanceCount = 1000

const gl = createGL({
        count: 36 * instanceCount, // Cube × instance count

        vertex: () => {
                const position = attribute('position')
                const instanceIndex = builtin('instanceIndex')

                // Instance position calculation
                const id = float(instanceIndex)
                const angle = id.mul(0.1)
                const radius = id.mul(0.05)

                const instancePos = vec3(cos(angle).mul(radius), sin(id.mul(0.3)).mul(2), sin(angle).mul(radius))

                // Add instance position
                const worldPos = position.add(instancePos)

                const mvpMatrix = uniform('mvpMatrix')
                return mvpMatrix.mul(vec4(worldPos, 1))
        },

        fragment: () => {
                const instanceIndex = builtin('instanceIndex')

                // Color per instance
                const hue = float(instanceIndex).mul(0.01)
                const color = vec3(sin(hue.mul(6.28)), sin(hue.mul(6.28).add(29)), sin(hue.mul(6.28).add(4.18)))

                return vec4(color, 1)
        },
})
```

## Camera Control

### Orbit Camera

```javascript
class OrbitCamera {
        constructor() {
                this.radius = 5
                this.theta = 0
                this.phi = Math.PI / 4
                this.target = [0, 0, 0]
        }

        update(deltaTheta, deltaPhi, deltaRadius) {
                this.theta += deltaTheta
                this.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.phi + deltaPhi))
                this.radius = Math.max(1, this.radius + deltaRadius)
        }

        getViewMatrix() {
                const x = this.radius * Math.sin(this.phi) * Math.cos(this.theta)
                const y = this.radius * Math.cos(this.phi)
                const z = this.radius * Math.sin(this.phi) * Math.sin(this.theta)

                const eye = [x, y, z]
                const up = [0, 1, 0]

                return createViewMatrix(eye, this.target, up)
        }
}

const camera = new OrbitCamera()

// Camera control with mouse
gl('mousemove', (event, x, y) => {
        if (isMouseDown) {
                const deltaX = x - lastMouseX
                const deltaY = y - lastMouseY

                camera.update(deltaX * 0.01, deltaY * 0.01, 0)

                lastMouseX = x
                lastMouseY = y
        }
})
```

### Fly-through Camera

```javascript
class FlyCamera {
        constructor() {
                this.position = [0, 0, 5]
                this.rotation = [0, 0] // pitch, yaw
                this.speed = 0.1
        }

        update(input) {
                const forward = this.getForward()
                const right = this.getRight()

                if (input.forward) {
                        this.position[0] += forward[0] * this.speed
                        this.position[1] += forward[1] * this.speed
                        this.position[2] += forward[2] * this.speed
                }

                if (input.right) {
                        this.position[0] += right[0] * this.speed
                        this.position[1] += right[1] * this.speed
                        this.position[2] += right[2] * this.speed
                }
        }

        getForward() {
                const pitch = this.rotation[0]
                const yaw = this.rotation[1]

                return [Math.sin(yaw) * Math.cos(pitch), -Math.sin(pitch), Math.cos(yaw) * Math.cos(pitch)]
        }

        getRight() {
                const yaw = this.rotation[1]
                return [Math.cos(yaw), 0, -Math.sin(yaw)]
        }
}
```

## Practical Exercises

### Exercise 1: 3D Scene

Create a 3D scene with multiple objects positioned in space.

### Exercise 2: Interactive Lighting

Create a lighting system where light sources can be moved with mouse interaction.

### Exercise 3: 3D Particles

Create a particle system operating in three-dimensional space.

## Common Issues and Solutions

### Z-Fighting

```javascript
// Improve depth buffer precision
const gl = createGL({
        depthBuffer: true,
        depthTest: true,
        near: 0.1, // Increase near
        far: 100, // Decrease far
})
```

### Normal Calculation

```javascript
// Correct normal transformation
const normalMatrix = transpose(inverse(modelMatrix))
const worldNormal = normalize(normalMatrix.mul(normal))
```

## What You've Learned

- ✅ Three-dimensional coordinate systems and projection
- ✅ Lighting systems
- ✅ 3D object generation
- ✅ Animation and deformation
- ✅ Spatial effects (fog, depth of field)
- ✅ Camera control systems

## Next Steps

Now that you've mastered 3D representation, learn about [Particles and Physics](08-particles-physics.md) to work with dynamic systems.

In the next chapter, you'll learn dynamic expressions using particle systems and physics simulations.
