# Particles and Physics

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

Learn to create dynamic particle systems and physics simulations for expressive visuals.

## Particle System Fundamentals

### Basic Particles

```javascript
// Particle data structure
class Particle {
        constructor(x, y, z) {
                this.position = [x, y, z]
                this.velocity = [0, 0, 0]
                this.acceleration = [0, 0, 0]
                this.life = 1
                this.maxLife = 1
                this.size = 1
                this.color = [1, 1, 1, 1]
        }

        update(deltaTime) {
                // Physics calculation
                this.velocity[0] += this.acceleration[0] * deltaTime
                this.velocity[1] += this.acceleration[1] * deltaTime
                this.velocity[2] += this.acceleration[2] * deltaTime

                this.position[0] += this.velocity[0] * deltaTime
                this.position[1] += this.velocity[1] * deltaTime
                this.position[2] += this.velocity[2] * deltaTime

                // Lifetime
                this.life -= deltaTime

                return this.life > 0
        }
}

// Particle system
class ParticleSystem {
        constructor(maxParticles) {
                this.particles = []
                this.maxParticles = maxParticles
                this.emissionRate = 10 // particles/second
                this.emissionTimer = 0
        }

        emit(count = 1) {
                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                        const particle = new Particle((Math.random() - 0.5) * 2, 0, (Math.random() - 0.5) * 2)

                        // Set random initial velocity
                        particle.velocity = [
                                (Math.random() - 0.5) * 4,
                                Math.random() * 8 + 2,
                                (Math.random() - 0.5) * 4,
                        ]

                        // Gravity
                        particle.acceleration = [0, -9.8, 0]

                        // Lifetime
                        particle.life = particle.maxLife = Math.random() * 3 + 1

                        this.particles.push(particle)
                }
        }

        update(deltaTime) {
                // Auto emission
                this.emissionTimer += deltaTime
                if (this.emissionTimer >= 1 / this.emissionRate) {
                        this.emit(1)
                        this.emissionTimer = 0
                }

                // Update particles
                this.particles = this.particles.filter((particle) => particle.update(deltaTime))
        }

        getPositions() {
                return this.particles.flatMap((p) => p.position)
        }

        getColors() {
                return this.particles.flatMap((p) => {
                        const life = p.life / p.maxLife
                        return [1, life, life * 0.5, life] // Color and alpha
                })
        }
}
```

### Particle Rendering

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const particlePositions = uniform('particlePositions')
        const particleColors = uniform('particleColors')
        const particleCount = uniform('particleCount')
        let finalColor = vec4(0.05, 0.05, 0.1, 1) // Background color
        // Render each particle
        Loop(100, ({ i }) => {
                // Max 100 particles
                If(float(i).lessThan(particleCount), () => {
                        const particlePos = vec3(
                                particlePositions[i * 3],
                                particlePositions[i * 3 + 1],
                                particlePositions[i * 3 + 2]
                        )
                        const particleColor = vec4(
                                particleColors[i * 4],
                                particleColors[i * 4 + 1],
                                particleColors[i * 4 + 2],
                                particleColors[i * 4 + 3]
                        )
                        // 3D to 2D projection (simplified)
                        const screenPos = particlePos.xy.div(particlePos.z.mul(0.1).add(1))
                        const distance = length(uv.sub(screenPos))
                        const particle = smoothstep(0.1, 0, distance)
                        // Alpha blending
                        const alpha = particle.mul(particleColor.a)
                        finalColor.assign(mix(finalColor, particleColor, alpha))
                })
        })
        return finalColor
}`}
/>

```javascript
const particleSystem = new ParticleSystem(1000)

// Animation loop
let lastTime = 0
gl('loop', () => {
        const currentTime = performance.now() / 1000
        const deltaTime = currentTime - lastTime
        lastTime = currentTime

        particleSystem.update(deltaTime)

        const positions = particleSystem.getPositions()
        const colors = particleSystem.getColors()

        gl.uniform('particlePositions', positions)
        gl.uniform('particleColors', colors)
        gl.uniform('particleCount', particleSystem.particles.length)
})
```

## Physics Effects

### Gravity and Wind

```javascript
class PhysicsParticleSystem extends ParticleSystem {
        constructor(maxParticles) {
                super(maxParticles)
                this.gravity = [0, -9.8, 0]
                this.wind = [2, 0, 1]
                this.damping = 0.99
        }

        update(deltaTime) {
                super.update(deltaTime)

                this.particles.forEach((particle) => {
                        // Apply gravity
                        particle.acceleration[0] = this.gravity[0] + this.wind[0]
                        particle.acceleration[1] = this.gravity[1] + this.wind[1]
                        particle.acceleration[2] = this.gravity[2] + this.wind[2]

                        // Air resistance
                        particle.velocity[0] *= this.damping
                        particle.velocity[1] *= this.damping
                        particle.velocity[2] *= this.damping
                })
        }

        setWind(x, y, z) {
                this.wind = [x, y, z]
        }
}

// Wind control
const physicsSystem = new PhysicsParticleSystem(500)

gl('mousemove', (event, x, y) => {
        // Control wind direction with mouse position
        const windX = x * 5
        const windZ = y * 5
        physicsSystem.setWind(windX, 0, windZ)
})
```

### Collision Detection

```javascript
class CollisionParticleSystem extends PhysicsParticleSystem {
        constructor(maxParticles) {
                super(maxParticles)
                this.ground = -3
                this.restitution = 0.7 // Coefficient of restitution
        }

        update(deltaTime) {
                super.update(deltaTime)

                this.particles.forEach((particle) => {
                        // Ground collision
                        if (particle.position[1] <= this.ground) {
                                particle.position[1] = this.ground
                                particle.velocity[1] = -particle.velocity[1] * this.restitution

                                // Friction
                                particle.velocity[0] *= 0.8
                                particle.velocity[2] *= 0.8
                        }

                        // Wall collision
                        const wallSize = 5
                        for (let axis = 0; axis < 3; axis += 2) {
                                // X, Z axes
                                if (particle.position[axis] > wallSize) {
                                        particle.position[axis] = wallSize
                                        particle.velocity[axis] = -particle.velocity[axis] * this.restitution
                                } else if (particle.position[axis] < -wallSize) {
                                        particle.position[axis] = -wallSize
                                        particle.velocity[axis] = -particle.velocity[axis] * this.restitution
                                }
                        }
                })
        }
}
```

### Particle Interactions

```javascript
class InteractiveParticleSystem extends CollisionParticleSystem {
        constructor(maxParticles) {
                super(maxParticles)
                this.attraction = 0.1
                this.repulsion = 0.5
                this.interactionRadius = 1
        }

        update(deltaTime) {
                // Calculate inter-particle forces
                for (let i = 0; i < this.particles.length; i++) {
                        const particleA = this.particles[i]

                        for (let j = i + 1; j < this.particles.length; j++) {
                                const particleB = this.particles[j]

                                const dx = particleB.position[0] - particleA.position[0]
                                const dy = particleB.position[1] - particleA.position[1]
                                const dz = particleB.position[2] - particleA.position[2]

                                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz)

                                if (distance < this.interactionRadius && distance > 0) {
                                        const force = distance < 0.5 ? this.repulsion : -this.attraction
                                        const fx = (dx / distance) * force
                                        const fy = (dy / distance) * force
                                        const fz = (dz / distance) * force

                                        particleA.acceleration[0] -= fx
                                        particleA.acceleration[1] -= fy
                                        particleA.acceleration[2] -= fz

                                        particleB.acceleration[0] += fx
                                        particleB.acceleration[1] += fy
                                        particleB.acceleration[2] += fz
                                }
                        }
                }

                super.update(deltaTime)
        }
}
```

## Special Effects

### Fire Effect

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const particlePositions = uniform('particlePositions')
        const particleCount = uniform('particleCount')
        let fireColor = vec3(0)
        Loop(50, ({ i }) => {
                If(float(i).lessThan(particleCount), () => {
                        const particlePos = vec2(particlePositions[i * 3], particlePositions[i * 3 + 1])
                        const distance = length(uv.sub(particlePos))
                        const life = particlePositions[i * 3 + 2] // Store lifetime in Z
                        // Fire colors (red→yellow→transparent)
                        const heat = smoothstep(0.3, 0, distance).mul(life)
                        const red = heat
                        const green = heat.mul(heat) // Square for yellow emphasis
                        const blue = heat.mul(heat).mul(heat) // Cube to suppress blue
                        fireColor.assign(fireColor.add(vec3(red, green, blue)))
                })
        })
        return vec4(fireColor, 1)
}`}
/>

```javascript
class FireParticleSystem extends ParticleSystem {
        emit(count = 1) {
                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                        const particle = new Particle(
                                (Math.random() - 0.5) * 0.5, // Emit from narrow range
                                0,
                                (Math.random() - 0.5) * 0.5
                        )

                        // Upward velocity
                        particle.velocity = [
                                (Math.random() - 0.5) * 2,
                                Math.random() * 6 + 2,
                                (Math.random() - 0.5) * 2,
                        ]

                        // Buoyancy (updraft)
                        particle.acceleration = [0, 2, 0]

                        particle.life = particle.maxLife = Math.random() * 2 + 0.5
                        particle.size = Math.random() * 0.3 + 0.1

                        this.particles.push(particle)
                }
        }
}

const fireSystem = new FireParticleSystem(200)
fireSystem.emissionRate = 30
```

### Water Effect

```javascript
class WaterParticleSystem extends ParticleSystem {
        constructor(maxParticles) {
                super(maxParticles)
                this.viscosity = 0.1
                this.surfaceTension = 0.05
        }

        emit(count = 1) {
                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                        const particle = new Particle((Math.random() - 0.5) * 1, 2, (Math.random() - 0.5) * 1)

                        particle.velocity = [(Math.random() - 0.5) * 3, Math.random() * 2, (Math.random() - 0.5) * 3]

                        particle.acceleration = [0, -9.8, 0]
                        particle.life = particle.maxLife = 5

                        this.particles.push(particle)
                }
        }

        update(deltaTime) {
                // Calculate viscosity forces
                this.particles.forEach((particleA, i) => {
                        let viscosityForce = [0, 0, 0]
                        let neighborCount = 0

                        this.particles.forEach((particleB, j) => {
                                if (i !== j) {
                                        const dx = particleB.position[0] - particleA.position[0]
                                        const dy = particleB.position[1] - particleA.position[1]
                                        const dz = particleB.position[2] - particleA.position[2]
                                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz)

                                        if (distance < 1) {
                                                viscosityForce[0] +=
                                                        (particleB.velocity[0] - particleA.velocity[0]) * this.viscosity
                                                viscosityForce[1] +=
                                                        (particleB.velocity[1] - particleA.velocity[1]) * this.viscosity
                                                viscosityForce[2] +=
                                                        (particleB.velocity[2] - particleA.velocity[2]) * this.viscosity
                                                neighborCount++
                                        }
                                }
                        })

                        if (neighborCount > 0) {
                                particleA.acceleration[0] += viscosityForce[0] / neighborCount
                                particleA.acceleration[1] += viscosityForce[1] / neighborCount
                                particleA.acceleration[2] += viscosityForce[2] / neighborCount
                        }
                })

                super.update(deltaTime)
        }
}
```

### Smoke Effect

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const particleData = uniform('particleData') // [x, y, z, size, life]
        const particleCount = uniform('particleCount')
        let smokeColor = vec4(0)
        Loop(25, ({ i }) => {
                If(float(i).lessThan(particleCount), () => {
                        const particlePos = vec2(particleData[i * 5], particleData[i * 5 + 1])
                        const size = particleData[i * 5 + 3]
                        const life = particleData[i * 5 + 4]
                        const distance = length(uv.sub(particlePos))
                        const smoke = smoothstep(size, size.mul(0.3), distance)
                        // Gray and semi-transparent
                        const intensity = smoke.mul(life).mul(0.3)
                        const smokeGray = vec4(vec3(0.7), intensity)
                        // Alpha blending
                        smokeColor.assign(mix(smokeColor, smokeGray, intensity))
                })
        })
        return smokeColor
}`}
/>

```javascript
class SmokeParticleSystem extends ParticleSystem {
        constructor(maxParticles) {
                super(maxParticles)
                this.turbulence = 0.5
        }

        emit(count = 1) {
                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                        const particle = new Particle((Math.random() - 0.5) * 0.3, 0, (Math.random() - 0.5) * 0.3)

                        particle.velocity = [
                                (Math.random() - 0.5) * 1,
                                Math.random() * 3 + 1,
                                (Math.random() - 0.5) * 1,
                        ]

                        particle.acceleration = [0, 0.5, 0] // Light upward movement
                        particle.life = particle.maxLife = Math.random() * 4 + 2
                        particle.size = Math.random() * 0.5 + 0.2

                        this.particles.push(particle)
                }
        }

        update(deltaTime) {
                const time = performance.now() / 1000

                this.particles.forEach((particle) => {
                        // Turbulence effect
                        const noiseX = Math.sin(particle.position[1] * 0.1 + time) * this.turbulence
                        const noiseZ = Math.cos(particle.position[1] * 0.1 + time * 1.3) * this.turbulence

                        particle.acceleration[0] = noiseX
                        particle.acceleration[2] = noiseZ

                        // Expansion
                        particle.size += deltaTime * 0.5
                })

                super.update(deltaTime)
        }
}

const smokeSystem = new SmokeParticleSystem(100)
```

## GPU Particles

### Acceleration with Compute Shaders

```javascript
// Using WebGPU
const computeShader = `
@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) id: vec3u) {
    let index = id.x;
    if (index >= arrayLength(&particles)) {
        return;
    }

    var particle = particles[index];

    // Physics calculation
    particle.velocity += particle.acceleration * uniforms.deltaTime;
    particle.position += particle.velocity * uniforms.deltaTime;

    // Lifetime
    particle.life -= uniforms.deltaTime;

    // Gravity
    particle.acceleration.y = -9.8;

    particles[index] = particle;
}
`

const gl = createGL({
        isWebGL: false, // WebGPU required
        compute: computeShader,

        fragment: () => {
                // Render using GPU particle data
                // ... GPU particle rendering logic

                return vec4(1, 0.5, 0.2, 1)
        },
})

// Massive particle count (100,000)
const particleCount = 100000
const particleData = new Float32Array(particleCount * 8) // position, velocity, life, size

gl.storage('particles', particleData)

gl('loop', () => {
        const deltaTime = 1 / 60
        gl.uniform('deltaTime', deltaTime)

        // Execute compute shader
        gl.compute.dispatch(Math.ceil(particleCount / 64), 1, 1)
})
```

## Performance Optimization

### Object Pool Pattern

```javascript
class PooledParticleSystem {
        constructor(maxParticles) {
                this.pool = []
                this.active = []

                // Pre-create particles
                for (let i = 0; i < maxParticles; i++) {
                        this.pool.push(new Particle(0, 0, 0))
                }
        }

        emit() {
                if (this.pool.length > 0) {
                        const particle = this.pool.pop()
                        // Initialize particle
                        particle.reset()
                        this.active.push(particle)
                }
        }

        update(deltaTime) {
                for (let i = this.active.length - 1; i >= 0; i--) {
                        const particle = this.active[i]

                        if (!particle.update(deltaTime)) {
                                // Return particle to pool
                                this.active.splice(i, 1)
                                this.pool.push(particle)
                        }
                }
        }
}
```

### Level of Detail

```javascript
class LODParticleSystem extends ParticleSystem {
        update(deltaTime) {
                const cameraDistance = this.getCameraDistance()

                // Adjust particle count based on distance
                let maxParticles
                if (cameraDistance < 10) {
                        maxParticles = 1000 // High quality
                } else if (cameraDistance < 50) {
                        maxParticles = 500 // Medium quality
                } else {
                        maxParticles = 100 // Low quality
                }

                // Remove excess particles
                while (this.particles.length > maxParticles) {
                        this.particles.pop()
                }

                super.update(deltaTime)
        }
}
```

## What You've Learned

- ✅ Particle system design
- ✅ Physics simulation (gravity, collision, interaction)
- ✅ Special effects (fire, water, smoke)
- ✅ GPU particles
- ✅ Performance optimization

## Next Steps

You've now mastered particles and physics! This completes your learning of all major GLRE features.

In the next chapter, you'll learn techniques for maintaining high performance even in large-scale projects.
