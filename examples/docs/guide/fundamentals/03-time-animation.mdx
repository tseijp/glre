# Time and Animation

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

Learn to create dynamic, moving visuals that change over time.

## Understanding Time

### Getting Time Values

In GLRE, you can easily access time to create animations:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Change color over time
        const red = sin(iTime)
        const green = sin(iTime.add(2))
        const blue = sin(iTime.add(4))
        return vec4(red, green, blue, 1)
}`}
/>

**What happens**: Colors smoothly cycle through different values, creating a rainbow effect.

### Basic Time Patterns

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Pattern A: Oscillation - smoothly goes up and down
        const oscillation = sin(iTime.mul(2))
        // Pattern B: Linear progression - steadily increases
        const linear = fract(iTime.mul(0.5))
        // Pattern C: Pulse - sharp peaks
        const pulse = smoothstep(0.7, 1, sin(iTime.mul(3)))
        // Mix patterns based on position
        const t = uv.x
        let pattern = mix(oscillation, linear, smoothstep(0, 0.5, t))
        pattern = mix(pattern, pulse, smoothstep(0.5, 1, t))
        const color = vec3(pattern, pattern.mul(0.8), pattern.mul(1.2))
        return vec4(color, 1)
}`}
/>

## Animation Patterns

### Rotation Animation

Spin things around in circles:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Rotation angle
        const angle = iTime.mul(1)
        // Apply rotation to coordinates
        const cosA = cos(angle)
        const sinA = sin(angle)
        const rotatedPos = vec2(
                uv.x.mul(cosA).sub(uv.y.mul(sinA)),
                uv.x.mul(sinA).add(uv.y.mul(cosA))
        )
        // Create stripes on rotated coordinates
        const stripe = sin(rotatedPos.x.mul(10))
        const color = vec3(stripe, stripe.mul(0.7), stripe.mul(0.9))
        return vec4(color, 1)
}`}
/>

### Scale Animation

Make things grow and shrink:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Pulsing effect
        const pulse = sin(iTime.mul(3))
        // Scale coordinates
        const scaledPos = uv.sub(0.5).div(pulse)
        // Distance from center
        const distance = length(scaledPos)
        // Circle that pulses
        const circle = smoothstep(0.5, 0.45, distance)
        const color = vec3(circle, circle.mul(0.8), circle.mul(1.2))
        return vec4(color, 1)
}`}
/>

### Wave Propagation

Create ripples spreading outward:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Distance from center
        const distance = length(uv.sub(0.5))
        // Wave that travels outward
        const wave = sin(distance.mul(20).sub(iTime.mul(8)))
        // Fade effect with distance
        const attenuation = oneMinus(distance)
        const finalWave = wave.mul(attenuation)
        const color = vec3(finalWave, finalWave.mul(0.6), finalWave.mul(1.4))
        return vec4(color, 1)
}`}
/>

**What this creates**: Ripples that start from the center and spread outward, like dropping a stone in water.

## Complex Animations

### Multiple Wave Frequencies

Combine different rhythms for complex patterns:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Different wave frequencies
        const wave1 = sin(iTime.mul(1)) // Slow
        const wave2 = sin(iTime.mul(1.6)) // Golden ratio frequency
        const wave3 = sin(iTime.mul(0.7)) // Another harmonic
        // Combine waves
        const composite = wave1.add(wave2.mul(0.5)).add(wave3.mul(0.25))
        const normalized = composite.div(1.75)
        // Apply to pattern
        const modulation = sin(uv.x.mul(5)).mul(sin(uv.y.mul(5)))
        const final = normalized.mul(modulation)
        const color = vec3(final, final.mul(0.8), final.mul(1.2))
        return vec4(color, 1)
}`}
/>

### Lissajous Curves

Mathematical curves that create beautiful patterns:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Lissajous curve (3/2 ratio)
        const x = sin(iTime.mul(2).add(iTime))
        const y = sin(iTime.mul(3))
        const curvePos = vec2(x, y).div(2)
        // Distance from curve
        const distance = length(uv.sub(0.5).sub(curvePos))
        // Draw the curve
        const curve = smoothstep(0.1, 0.05, distance)
        // Add trail effect
        const history = sin(distance.mul(30).sub(iTime.mul(5)))
        const historyMask = smoothstep(0.8, 0.2, distance)
        const final = max(curve, history.mul(historyMask).mul(0.3))
        const color = vec3(final, final.mul(0.7), final.mul(1.3))
        return vec4(color, 1)
}`}
/>

## Easing Functions

### Smooth Transitions

Instead of linear changes, use easing for more natural motion:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Time cycles between 0 and 1
        const t = fract(iTime.mul(0.5))
        // Different easing functions
        const easeInOut = t.mul(t).mul(3).sub(t.mul(t).mul(2))
        const easeInQuart = t.mul(t).mul(t).mul(t)
        // Elastic easing approximation
        const elastic = sin(t.mul(6.28318).mul(3)).mul(pow(2, negate(t.mul(8))))
        // Choose easing based on Y position
        const y = uv.y
        let ease = mix(t, easeInOut, step(0.33, y))
        ease = mix(ease, easeInQuart, step(0.66, y))
        // Apply easing to position
        const animatedPos = uv.x.add(ease.sub(0.5).mul(2))
        const pattern = sin(animatedPos.mul(8))
        const color = vec3(pattern, pattern.mul(0.8), pattern.mul(1.2))
        return vec4(color, 1)
}`}
/>

## Interactive Animations

### Mouse-Controlled Effects

Combine time with mouse position:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Distance from mouse (simulated at center for demo)
        const distance = length(uv.sub(iMouse.div(2)))
        // Time-based ripples from mouse position
        const ripple = sin(distance.mul(15).sub(iTime.mul(10)))
        const rippleMask = smoothstep(0.8, 0, distance)
        // Background pattern
        const background = sin(uv.x.mul(10).add(iTime)).mul(sin(uv.y.mul(10).add(iTime)))
        // Combine effects
        const final = background.mul(0.3).add(ripple.mul(rippleMask).mul(0.7))
        const color = vec3(final)
        return vec4(color, 1)
}`}
/>

## Time-Based Effects

### Kaleidoscope

Create a kaleidoscope effect that changes over time:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Convert to polar coordinates
        let radius = length(uv.sub(0.5))
        let angle = atan2(uv.y.sub(0.5), uv.x.sub(0.5))
        // Kaleidoscope symmetry
        const sections = 6
        angle = angle.div(6).mul(sections)
        angle = abs(fract(angle).sub(0.5)).mul(2)
        angle = angle.mul(6).div(sections)
        // Time-based rotation
        angle = angle.add(iTime.mul(0.5))
        // Radial waves
        radius = radius.add(sin(angle.mul(8).add(iTime.mul(2))).mul(0.1))
        // Pattern generation
        const pattern1 = sin(radius.mul(20).sub(iTime.mul(3)))
        const pattern2 = sin(angle.mul(12).add(radius.mul(15)))
        const combined = pattern1.mul(pattern2)
        // Rainbow colors
        const colorPhase = angle.add(iTime)
        const color = vec3(
                sin(colorPhase),
                sin(colorPhase.add(29)),
                sin(colorPhase.add(4.18))
        ).mul(combined)
        return vec4(color, 1)
}`}
/>

## Advanced Techniques

### Metaballs Animation

Create organic-looking blobs that move and merge:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Multiple moving points
        const point1 = vec2(sin(iTime.mul(0.8)).mul(0.3), cos(iTime.mul(0.6)).mul(0.4))
        const point2 = vec2(sin(iTime.mul(1.2)).mul(0.4), cos(iTime.mul(0.9)).mul(0.3))
        const point3 = vec2(sin(iTime.mul(0.5)).mul(0.2), cos(iTime.mul(1.1)).mul(0.5))
        // Calculate distance fields
        const pos = uv.sub(0.5).mul(2)
        const dist1 = length(pos.sub(point1))
        const dist2 = length(pos.sub(point2))
        const dist3 = length(pos.sub(point3))
        // Metaball formula
        const field = oneMinus(dist1).add(oneMinus(dist2)).add(oneMinus(dist3))
        const threshold = float(0.8)
        const metaball = smoothstep(threshold.sub(0.1), threshold.add(0.1), field)
        // Color based on field strength
        const color = vec3(field.mul(0.5), metaball, field.mul(metaball))
        return vec4(color, 1)
}`}
/>

### Fractal Zoom

Create an infinite zooming effect:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Zoom factor that increases over time
        const zoom = pow(10, sin(iTime))
        // Apply zoom to coordinates
        let pos = uv.sub(0.5).mul(zoom)
        // Keep pattern within bounds using modulo
        pos = fract(pos).sub(0.5)
        // Create fractal-like pattern
        let pattern = float(0)
        for (let i = 0; i < 3; i += 1) {
                const scale = pow(2, i)
                const layer = sin(pos.x.mul(scale).mul(8)).mul(sin(pos.y.mul(scale).mul(8)))
                pattern = pattern.add(layer.div(scale))
        }
        pattern = pattern
        // Color with time-based hue shift
        const hue = iTime.mul(0.1)
        const color = vec3(
                sin(hue),
                sin(hue.add(29)),
                sin(hue.add(4.18))
        ).mul(pattern)
        return vec4(color, 1)
}`}
/>

## What You've Learned

- ✅ Time access and basic animation
- ✅ Rotation, scaling, and wave animations
- ✅ Complex pattern combinations
- ✅ Easing functions for smooth motion
- ✅ Interactive time-based effects
- ✅ Animation control systems

## Next Steps

Now that you can create dynamic visuals, learn about [Shapes and Patterns](../techniques/04-shapes-patterns.md) to draw specific forms and complex designs.
