# Time and Animation

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

Learn to create dynamic, moving visuals that change over time.

## Understanding Time

### Getting Time Values

In GLRE, you can easily access time to create animations:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Change color over time
        const red = iTime.sin()
        const green = iTime.add(2).sin()
        const blue = iTime.add(4).sin()
        return vec4(red, green, blue, 1)
}`}
/>

**What happens**: Colors smoothly cycle through different values, creating a rainbow effect.

### Basic Time Patterns

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Pattern A: Oscillation - smoothly goes up and down
        const oscillation = iTime.mul(2).sin()
        // Pattern B: Linear progression - steadily increases
        const linear = iTime.mul(0.5).fract()
        // Pattern C: Pulse - sharp peaks
        const pulseInput = iTime.mul(3).sin()
        const pulse = smoothstep(0.7, 1, pulseInput)
        // Mix patterns based on position
        const t = uv.x
        const mixRatio1 = smoothstep(0, 0.5, t)
        let pattern = mix(oscillation, linear, mixRatio1)
        const mixRatio2 = smoothstep(0.5, 1, t)
        pattern = mix(pattern, pulse, mixRatio2)
        const color = vec3(1, 0.8, 1.2).mul(pattern)
        return vec4(color, 1)
}`}
/>

## Animation Patterns

### Rotation Animation

Spin things around in circles:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Rotation angle
        const angle = iTime.mul(1)
        // Apply rotation to coordinates
        const cosA = angle.cos()
        const sinA = angle.sin()
        const rotateMat = mat2(cosA, sinA, sinA.negate(), cosA)
        const rotatePos = rotateMat.mul(uv)
        // Create stripes on rotated coordinates
        const stripe = rotatePos.x.mul(10).sin()
        return vec4(vec3(stripe), 1)
}`}
/>

### Scale Animation

Make things grow and shrink:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Pulsing effect
        const pulse = iTime.mul(3).sin()
        // Scale coordinates
        const scaledPos = uv.sub(0.5).div(pulse)
        // Distance from center
        const distance = scaledPos.length()
        // Circle that pulses
        const circle = smoothstep(0.5, 0.45, distance)
        const color = vec3(1, 0.8, 1.2).mul(circle)
        return vec4(color, 1)
}`}
/>

### Wave Propagation

Create ripples spreading outward:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Distance from center
        const distance = uv.sub(0.5).length()
        // Wave that travels outward
        const timeOffset = iTime.mul(8)
        const waveInput = distance.mul(20).sub(timeOffset)
        const wave = waveInput.sin()
        // Fade effect with distance
        const attenuation = distance.oneMinus()
        const finalWave = wave.mul(attenuation)
        const color = vec3(1, 0.6, 1.4).mul(finalWave)
        return vec4(color, 1)
}`}
/>

**What this creates**: Ripples that start from the center and spread outward, like dropping a stone in water.

## Complex Animations

### Multiple Wave Frequencies

Combine different rhythms for complex patterns:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Different wave frequencies
        const wave1 = iTime.mul(1).sin() // Slow
        const wave2 = iTime.mul(1.6).sin() // Golden ratio frequency
        const wave3 = iTime.mul(0.7).sin() // Another harmonic
        // Combine waves
        const wave2Scaled = wave2.mul(0.5)
        const wave3Scaled = wave3.mul(0.25)
        const composite = wave1.add(wave2Scaled).add(wave3Scaled)
        const normalized = composite.div(1.75)
        // Apply to pattern
        const modulationX = uv.x.mul(5).sin()
        const modulationY = uv.y.mul(5).sin()
        const modulation = modulationX.mul(modulationY)
        const final = normalized.mul(modulation)
        const color = vec3(1, 0.8, 1.2).mul(final)
        return vec4(color, 1)
}`}
/>

### Lissajous Curves

Mathematical curves that create beautiful patterns:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Lissajous curve (3/2 ratio)
        const x = iTime.mul(3).add(iTime).sin()
        const y = iTime.mul(2).sin()
        const curvePos = vec2(x, y).div(2)
        // Distance from curve
        const distance = uv.sub(0.5).sub(curvePos).length()
        // Draw the curve
        const curve = smoothstep(0.1, 0.05, distance)
        // Add trail effect
        const timeOffset = iTime.mul(5)
        const historyInput = distance.mul(30).sub(timeOffset)
        const history = historyInput.sin()
        const historyMask = smoothstep(0.8, 0.2, distance)
        const historyEffect = history.mul(historyMask).mul(0.3)
        const final = max(curve, historyEffect)
        const color = vec3(1, 0.7, 1.3).mul(final)
        return vec4(color, 1)
}`}
/>

## Easing Functions

### Smooth Transitions

Instead of linear changes, use easing for more natural motion:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Time cycles between 0 and 1
        const t = iTime.mul(0.5).fract()
        // Different easing functions
        const tSquared = t.mul(t)
        const easeComponent1 = tSquared.mul(3)
        const easeComponent2 = tSquared.mul(2)
        const easeInOut = easeComponent1.sub(easeComponent2)
        const easeInQuart = t.mul(t).mul(t).mul(t)
        // Elastic easing approximation
        const elasticInput = t.mul(6.28318).mul(3).sin()
        const decayExponent = t.mul(8).negate()
        const elasticDecay = pow(2, decayExponent)
        const elastic = elasticInput.mul(elasticDecay)
        // Choose easing based on Y position
        const y = uv.y
        const easeStep1 = step(0.33, y)
        let ease = mix(t, easeInOut, easeStep1)
        const easeStep2 = step(0.66, y)
        ease = mix(ease, easeInQuart, easeStep2)
        // Apply easing to position
        const easeOffset = ease.sub(0.5).mul(2)
        const animatedPos = uv.x.add(easeOffset)
        const pattern = animatedPos.mul(8).sin()
        const color = vec3(1, 0.8, 1.2).mul(pattern)
        return vec4(color, 1)
}`}
/>

## Interactive Animations

### Mouse-Controlled Effects

Combine time with mouse position:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Distance from mouse (simulated at center for demo)
        const mouseCenter = iMouse.div(2)
        const distance = uv.sub(mouseCenter).length()
        // Time-based ripples from mouse position
        const rippleTime = iTime.mul(10)
        const rippleInput = distance.mul(15).sub(rippleTime)
        const ripple = rippleInput.sin()
        const rippleMask = smoothstep(0.8, 0, distance)
        // Background pattern
        const backgroundX = uv.x.mul(10).add(iTime).sin()
        const backgroundY = uv.y.mul(10).add(iTime).sin()
        const background = backgroundX.mul(backgroundY)
        // Combine effects
        const backgroundEffect = background.mul(0.3)
        const rippleEffect = ripple.mul(rippleMask).mul(0.7)
        const final = backgroundEffect.add(rippleEffect)
        const color = vec3(final)
        return vec4(color, 1)
}`}
/>

## Time-Based Effects

### Kaleidoscope

Create a kaleidoscope effect that changes over time:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Convert to polar coordinates
        let radius = uv.sub(0.5).length()
        const centeredPos = uv.sub(0.5)
        let angle = atan2(centeredPos.y, centeredPos.x)
        // Kaleidoscope symmetry
        const sections = 6
        angle = angle.div(6).mul(sections)
        angle = angle.fract().sub(0.5).abs().mul(2)
        angle = angle.mul(6).div(sections)
        // Time-based rotation
        const timeRotation = iTime.mul(0.5)
        angle = angle.add(timeRotation)
        // Radial waves
        const timeComponent = iTime.mul(2)
        const radiusWave = angle.mul(8).add(timeComponent).sin()
        const radiusModulation = radiusWave.mul(0.1)
        radius = radius.add(radiusModulation)
        // Pattern generation
        const pattern1Time = iTime.mul(3)
        const pattern1Input = radius.mul(20).sub(pattern1Time)
        const pattern1 = pattern1Input.sin()
        const radiusComponent = radius.mul(15)
        const pattern2Input = angle.mul(12).add(radiusComponent)
        const pattern2 = pattern2Input.sin()
        const combined = pattern1.mul(pattern2)
        // Rainbow colors
        const colorPhase = angle.add(iTime)
        const color = vec3(
                colorPhase.sin(),
                colorPhase.add(29).sin(),
                colorPhase.add(4.18).sin()
        ).mul(combined)
        return vec4(color, 1)
}`}
/>

## Advanced Techniques

### Metaballs Animation

Create organic-looking blobs that move and merge:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Multiple moving points using matrix operations
        const timeMatrix = constant(mat3(
                0.8, 0, 0,
                0, 1.2, 0,
                0, 0, 0.5
        ))
        const timeMatrixY = constant(mat3(
                0.6, 0, 0,
                0, 0.9, 0,
                0, 0, 1.1
        ))
        const amplitudeMatrix = constant(mat3(
                0.3, 0, 0,
                0, 0.4, 0,
                0, 0, 0.2
        ))
        const amplitudeMatrixY = constant(mat3(
                0.4, 0, 0,
                0, 0.3, 0,
                0, 0, 0.5
        ))
        const timeVector = vec3(iTime)
        const sinValues = timeMatrix.mul(timeVector).sin()
        const cosValues = timeMatrixY.mul(timeVector).cos()
        const pointsX = amplitudeMatrix.mul(sinValues)
        const pointsY = amplitudeMatrixY.mul(cosValues)
        // Calculate distance fields using vectorized operations
        const pos = uv.sub(0.5).mul(2)
        const distances = vec3(
                pos.sub(vec2(pointsX.x, pointsY.x)).length(),
                pos.sub(vec2(pointsX.y, pointsY.y)).length(),
                pos.sub(vec2(pointsX.z, pointsY.z)).length()
        )
        // Metaball formula - vectorized field calculation
        const fields = distances.oneMinus()
        const field = fields.x.add(fields.y).add(fields.z)
        const metaball = smoothstep(0.8 - 0.1, 0.8 + 0.1, field)
        // Color based on field strength
        const colorFactors = vec3(0.5, 1, metaball)
        const color = vec3(field, metaball, field).mul(colorFactors)
        return vec4(color, 1)
}`}
/>

### Fractal Zoom

Create an infinite zooming effect:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Zoom factor that increases over time
        const zoomExponent = iTime.sin()
        const zoom = pow(10, zoomExponent)
        // Apply zoom to coordinates
        let pos = uv.sub(0.5).mul(zoom)
        // Keep pattern within bounds using modulo
        pos = pos.fract().sub(0.5)
        // Create fractal-like pattern
        let pattern = float(0)
        for (let i = 0; i < 3; i += 1) {
                const scale = pow(2, i)
                const layerPattern = pos.mul(scale).mul(8).sin()
                const layer = layerPattern.x.mul(layerPattern.y)
                const layerContribution = layer.div(scale)
                pattern = pattern.add(layerContribution)
        }
        // Color with time-based hue shift
        const hue = iTime.mul(0.1)
        const color = vec3(
                hue.sin(),
                hue.add(29).sin(),
                hue.add(4.18).sin()
        ).mul(pattern)
        return vec4(color, 1)
}`}
/>

## What You've Learned

- ✅ Time access and basic animation
- ✅ Rotation, scaling, and wave animations
- ✅ Complex pattern combinations
- ✅ Easing functions for smooth motion
- ✅ Interactive time-based effects
- ✅ Animation control systems

## Next Steps

Now that you can create dynamic visuals, learn about [Shapes and Patterns](../techniques/04-shapes-patterns.mdx) to draw specific forms and complex designs.
