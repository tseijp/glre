# Colors and Coordinates

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

Learn detailed color manipulation and coordinate transformations.

## Understanding Color Systems

### Color Blending

Mix two colors together smoothly:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Two colors to blend
        const color1 = vec3(1, 0.2, 0.3) // Reddish
        const color2 = vec3(0.2, 0.6, 1) // Bluish
        // X coordinate determines blend ratio
        const mixRatio = uv.x
        // Blend the colors
        const blendedColor = mix(color1, color2, mixRatio)
        return vec4(blendedColor, 1)
}`}
/>

**What `mix()` does**:

- When `mixRatio` = 0: returns `color1`
- When `mixRatio` = 1: returns `color2`
- When `mixRatio` = 0.5: returns halfway between both colors

### RGB vs HSV

RGB (Red, Green, Blue) is like mixing colored lights, while HSV (Hue, Saturation, Value) is more intuitive for artists.

**RGB**: Mix red, green, and blue light
**HSV**: Pick a color (hue), make it vibrant (saturation), make it bright (value)

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // HSV to RGB conversion function
        const rgb2hsv = Fn(([h, s, v]) => {
                const c = v.mul(s)
                const x = c.mul(mod(h.mul(6), 2).sub(1).abs().oneMinus())
                const m = v.sub(c)
                const i = floor(h.mul(6))
                If(i.equal(0), () => vec3(c, x, 0).add(m))
                .ElseIf(i.equal(1), () => vec3(x, c, 0).add(m))
                .ElseIf(i.equal(2), () => vec3(0, c, x).add(m))
                .ElseIf(i.equal(3), () => vec3(0, x, c).add(m))
                .ElseIf(i.equal(4), () => vec3(x, 0, c).add(m))
                .Else(() => vec3(c, 0, x).add(m))
        })
        // HSV-style color creation
        const h = uv.x // Hue from position
        const s = sin(iTime).abs() // Saturation
        const v = uv.y // Value / brightness
        // Convert HSV to RGB using the function
        const rgb = rgb2hsv(h, s, v)
        return vec4(rgb, 1)
}`}
/>

### RGB vs XYZ

The CIE color space represents colors as chromaticity coordinates, independent of brightness. It's visualized as the famous "horseshoe" chromaticity diagram.

**How it works**:

- x, y coordinates represent color hue and saturation
- Pure colors form the curved boundary (spectral locus)
- Mixed colors appear inside the horseshoe shape
- White point is at the center

<FragmentEditor
        isFun
        code={`
const XYZtoRGB = constant(mat3(
        3.2406, -1.5372, -0.4986,
        -0.9689, 1.8758, 0.0415,
        0.0557, -0.2040, 1.0570
))
const fragment = () => {
        // CIE xy chromaticity coordinates from UV
        const x = uv.x
        const y = uv.y
        const z = float(1).sub(x).sub(y)
        // Convert xy to XYZ (assuming Y = 1 for full brightness)
        const Y = sin(iTime).abs()
        const X = x.mul(Y).div(y)
        const Z = z.mul(Y).div(y)
        // XYZ to RGB conversion matrix (sRGB)
        // Convert XYZ to RGB
        const rgb = XYZtoRGB.mul(vec3(X, Y, Z))
        // Clamp to valid range and check if within gamut
        return vec4(rgb, 1)
}`}
/>

## Coordinate Transformations

### Moving, Scaling, and Rotating

Think of coordinates like a piece of paper you can move, resize, and turn:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Move coordinates (translation)
        const offset = vec2(0.3, -0.2)
        const movedPos = uv.add(offset)
        // Scale coordinates (make bigger/smaller)
        const scale = 2
        const scaledPos = movedPos.mul(scale)
        // Rotate coordinates
        const angle = 0.5 // radians (about 30 degrees)
        const cosA = cos(angle)
        const sinA = sin(angle)
        const rotatedPos = vec2(
                scaledPos.x.mul(cosA).sub(scaledPos.y.mul(sinA)),
                scaledPos.x.mul(sinA).add(scaledPos.y.mul(cosA))
        )
        // Use transformed coordinates for color
        const color = vec3(rotatedPos, 0.5)
        return vec4(color, 1)
}`}
/>

### Polar Coordinates

Sometimes it's easier to think in circles rather than squares:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Convert to polar coordinates (radius and angle)
        const angle = atan2(uv.y.sub(0.5), uv.x.sub(0.5)) // Angle around center
        // Use angle for hue (color wheel effect)
        const hue = angle.div(6).add(0.5) // Convert -π→π to 0→1
        // Use radius for brightness
        const radius = length(uv.sub(0.5)) // Distance from center
        const brightness = oneMinus(radius)
        // Create color wheel
        const color = vec3(
                sin(hue.mul(6)),
                cos(hue.mul(6).add(2)),
                sin(hue.mul(6).add(4))
        ).mul(brightness)
        return vec4(color, 1)
}`}
/>

**What this creates**: A circular rainbow that fades to black at the edges.

## Creating Patterns

### Checkerboard Pattern

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Divide screen into grid cells
        const scale = 8
        const gridPos = uv.mul(scale)
        // Get cell indices
        const cellX = floor(gridPos.x)
        const cellY = floor(gridPos.y)
        // Checkerboard pattern
        const checker = mod(cellX.add(cellY), 2)
        // Alternate between white and black
        const color = vec3(checker)
        return vec4(color, 1)
}`}
/>

### Stripe Patterns

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Vertical stripes
        const frequency = 100
        const stripe = sin(uv.x.mul(frequency))
        // Diagonal stripes
        const diagonal = sin(uv.x.add(uv.y).mul(frequency))
        // Combine patterns
        const pattern = mix(stripe, diagonal, 0.5)
        const color = vec3(pattern, pattern.mul(0.8), pattern.mul(0.6))
        return vec4(color, 1)
}`}
/>

### Circular Patterns

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Distance from center
        const distance = length(uv.sub(0.5))
        // Concentric circles
        const rings = sin(distance.mul(30))
        // Smooth ring edges
        const ringWidth = 0.1
        const smoothRings = smoothstep(0, ringWidth, rings)
        // Combine with gradient
        const gradient = oneMinus(distance)
        const finalPattern = smoothRings.mul(gradient)
        const color = vec3(finalPattern, finalPattern.mul(0.8), finalPattern.mul(1.2))
        return vec4(color, 1)
}`}
/>

## Useful Effects

### Vignette Effect

Darken the edges of the screen:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Base color
        const baseColor = vec3(0.8, 0.9, 1)
        // Vignette based on distance from center
        const distance = length(uv.sub(0.5))
        const vignette = smoothstep(0.8, 0.2, distance)
        const finalColor = baseColor.mul(vignette)
        return vec4(finalColor, 1)
}`}
/>

### Grid Lines

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Grid settings
        const gridSize = 0.1
        const lineWidth = 0.05
        // Calculate grid lines
        const grid = abs(fract(uv.div(gridSize)).sub(0.5))
        const gridLines = smoothstep(0, lineWidth, min(grid.x, grid.y))
        // Background color
        const backgroundColor = vec3(0.1, 0.1, 0.2)
        // Grid color
        const gridColor = vec3(0.3, 0.3, 0.5)
        // Blend background and grid
        const finalColor = mix(gridColor, backgroundColor, gridLines)
        return vec4(finalColor, 1)
}`}
/>

## Mathematical Functions Explained

### Wave Functions

These create repeating patterns:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Sine wave: smooth up and down motion
        const sine = sin(uv.x.mul(8))
        // Sawtooth wave: ramp up, then jump down
        const sawtooth = fract(uv.x.mul(4))
        // Square wave: switches between high and low
        const square = step(0.5, uv.x.mul(4).fract())
        // Choose wave based on Y position
        const waveSelect = uv.y
        const wave1 = mix(sine, sawtooth, step(1 / 3, waveSelect))
        const wave2 = mix(wave1, square, step(2 / 3, waveSelect))
        const color = vec3(wave2, wave2.mul(0.8), wave2.mul(1.2))
        return vec4(color, 1)
}`}
/>

### Random Patterns

Create seemingly random variations:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Grid cells
        const scale = 10
        const cellPos = floor(uv.mul(scale))
        // Pseudo-random function
        const random = Fn(([xy]) => {
                return fract(sin(dot(xy, vec2(12.9898, 78.233))).mul(43758.5453123))
        })
        // Random color per cell
        const color = vec3(
                random(cellPos),
                random(cellPos.add(vec2(1, 0))),
                random(cellPos.add(vec2(0, 1)))
        )
        return vec4(color, 1)
}`}
/>

### Fractal Noise

Create complex organic patterns by layering simple noise:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const random = Fn(([xy]) => {
                return fract(sin(dot(xy, vec2(12.9898, 78.233))).mul(43758.5453))
        })
        const noise = Fn(([xy]) => {
                const i = floor(xy).toVar()
                const f = fract(xy).toVar()
                const u = f.mul(f).mul(f.sub(2).negate()).toVar()
                return mix(
                        mix(random(i), random(i.add(vec2(1, 0))), u.x),
                        mix(random(i.add(vec2(0, 1))), random(i.add(vec2(1, 1))), u.x),
                        u.y
                )
        })
        const fbm = Fn(([xy]) => {
                return noise(xy).mul(0.5)
                .add(noise(xy.mul(2)).mul(0.25))
                .add(noise(xy.mul(4)).mul(0.125))
                .add(noise(xy.mul(8)).mul(0.0625))
        })
        const color = vec3(fbm(uv.mul(8)))
        return vec4(color, 1)
}`}
/>

## What You've Learned

- ✅ RGB and HSV color systems
- ✅ Color blending and adjustments
- ✅ Coordinate transformations (move, scale, rotate)
- ✅ Polar coordinate system
- ✅ Pattern generation
- ✅ Mathematical function applications

## Next Steps

Now that you understand colors and coordinates, learn about [Time and Animation](03-time-animation.md) to make your visuals move and change dynamically.
