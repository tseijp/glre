import { FragmentEditor } from '@site/src/theme/FragmentEditor'

# Images and Textures

Learn how to load and process external images, and techniques for texture-based expressions.

## Loading Images

### Basic Image Loading

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://avatars.githubusercontent.com/u/40712342')
        const uv = position.xy.div(iResolution) // Calculate correct UV coordinates
        // Get pixel color from texture
        const textureColor = texture(iTexture, uv)
        return textureColor
}`}
/>

### Understanding UV Coordinates

UV coordinates are a coordinate system that represents positions on an image:

```
(0,0) -------- (1,0)
  |              |
  |     Image    |
  |              |
(0,1) -------- (1,1)
```

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const uvColor = vec4(uv.x, uv.y, 0, 1)
        return uvColor
}`}
/>

## Image Filters

### Blur Effect

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://avatars.githubusercontent.com/u/40712342')
        
        // Improved blur filter function with configurable sampling size
        const blurFilter = Fn(([uv, blurRadius, size]) => {
                let blurColor = vec4(0).toVar()
                let totalWeight = float(0).toVar()
                const pixelSize = vec2(float(1)).div(iResolution)
                const halfSize = size.div(float(2))
                const totalSamples = int(size.mul(size))
                
                // Dynamic sampling based on size parameter
                Loop(totalSamples, ({ i }) => {
                        const x = mod(float(i), size).sub(halfSize)
                        const y = floor(float(i).div(size)).sub(halfSize)
                        
                        // Calculate distance from center for weight
                        const dist = length(vec2(x, y))
                        const weight = exp(dist.mul(dist).mul(float(-0.5)))
                        
                        // Sample offset
                        const offset = vec2(x, y).mul(pixelSize).mul(blurRadius)
                        const sampleUV = uv.add(offset)
                        
                        // Clamp UV coordinates to prevent artifacts
                        const clampedUV = clamp(sampleUV, vec2(0), vec2(1))
                        const sampleColor = texture(iTexture, clampedUV)
                        
                        blurColor.assign(blurColor.add(sampleColor.mul(weight)))
                        totalWeight.assign(totalWeight.add(weight))
                })
                
                // Normalize by total weight
                return blurColor.div(totalWeight)
        })
        
        // Configurable parameters
        const blurRadius = float(2.0)
        const kernelSize = float(5)
        
        // Apply blur filter
        const blurColor = blurFilter(uv, blurRadius, kernelSize)
        return blurColor
}`}
/>

### Edge Detection

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://avatars.githubusercontent.com/u/40712342')
        const step = vec2(1).div(iResolution)
        
        // Sample 3x3 neighborhood as vectors
        const sample = (x, y) => texture(iTexture, uv.add(vec2(x, y).mul(step))).r
        const row1 = vec3(sample(-1, -1), sample(0, -1), sample(1, -1))
        const row2 = vec3(sample(-1, 0),  sample(0, 0),  sample(1, 0))
        const row3 = vec3(sample(-1, 1),  sample(0, 1),  sample(1, 1))
        
        // Sobel X kernel
        const kx1 = vec3(-1, 0, 1)
        const kx2 = vec3(-2, 0, 2)
        const kx3 = vec3(-1, 0, 1)
        
        // Sobel Y kernel
        const ky1 = vec3(-1, -2, -1)
        const ky2 = vec3(0, 0, 0)
        const ky3 = vec3(1, 2, 1)
        
        // Matrix convolution using dot products
        const gx = dot(row1, kx1).add(dot(row2, kx2)).add(dot(row3, kx3))
        const gy = dot(row1, ky1).add(dot(row2, ky2)).add(dot(row3, ky3))
        
        const edgeStrength = length(vec2(gx, gy))
        return vec4(vec3(edgeStrength), 1)
}`}
/>

### Sepia Tone

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://avatars.githubusercontent.com/u/40712342')
        const originalColor = texture(iTexture, uv)
        // Sepia tone conversion matrix
        const sepiaR = originalColor.r
                .mul(float(0.393))
                .add(originalColor.g.mul(float(0.769)))
                .add(originalColor.b.mul(float(0.189)))
        const sepiaG = originalColor.r
                .mul(float(0.349))
                .add(originalColor.g.mul(float(0.686)))
                .add(originalColor.b.mul(float(0.168)))
        const sepiaB = originalColor.r
                .mul(float(0.272))
                .add(originalColor.g.mul(float(0.534)))
                .add(originalColor.b.mul(float(0.131)))
        const sepiaColor = vec4(sepiaR, sepiaG, sepiaB, originalColor.a)
        return sepiaColor
}`}
/>

## Texture Coordinate Manipulation

### Texture Tiling

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://avatars.githubusercontent.com/u/40712342')
        // Scale coordinates and repeat
        const scale = float(3)
        const repeatedUV = fract(uv.mul(scale))
        const textureColor = texture(iTexture, repeatedUV)
        return textureColor
}`}
/>

### Texture Rotation

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://avatars.githubusercontent.com/u/40712342')
        // Center coordinates (-0.5 to 0.5)
        const centeredUV = uv.sub(vec2(0.5))
        // Rotation
        const angle = iTime.mul(float(0.5))
        const cosA = cos(angle)
        const sinA = sin(angle)
        const rotatedUV = vec2(
                centeredUV.x.mul(cosA).sub(centeredUV.y.mul(sinA)),
                centeredUV.x.mul(sinA).add(centeredUV.y.mul(cosA))
        ).add(vec2(0.5))
        // Wrap out-of-bounds to repeat
        const wrappedUV = fract(rotatedUV)
        const textureColor = texture(iTexture, wrappedUV)
        return textureColor
}`}
/>

### Fisheye Lens Effect

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://avatars.githubusercontent.com/u/40712342')
        const radius = length(position.xy)
        const angle = atan2(position.y, position.x)
        // Fisheye effect calculation
        const distortedRadius = radius.mul(radius).mul(float(0.5)).add(radius.mul(float(0.5)))
        const distortedPos = vec2(cos(angle).mul(distortedRadius), sin(angle).mul(distortedRadius))
        const uv = distortedPos.div(iResolution)
        // Make out-of-bounds black
        const inBounds = step(radius, float(1))
        const textureColor = texture(iTexture, uv).mul(inBounds)
        return textureColor
}`}
/>

## Multi-Texture

### Multiple Image Composition

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const texture1 = uniform('https://avatars.githubusercontent.com/u/40712342')
        const texture2 = uniform('https://picsum.photos/512/512?random=1')
        const maskTexture = uniform('https://picsum.photos/512/512?random=2')
        // Load multiple textures
        const tex1 = texture(texture1, uv)
        const tex2 = texture(texture2, uv)
        const maskTex = texture(maskTexture, uv)
        // Composition using mask
        const mask = maskTex.r
        const blendedColor = mix(tex1, tex2, mask)
        return blendedColor
}`}
/>

```javascript
// Example of setting multiple textures in JavaScript
gl.texture('texture1', './images/background.jpg')
gl.texture('texture2', './images/overlay.jpg')
gl.texture('maskTexture', './images/mask.jpg')
```

### Gradient Mask

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const texture1 = uniform('https://avatars.githubusercontent.com/u/40712342')
        const texture2 = uniform('https://picsum.photos/512/512?random=3')
        const tex1 = texture(texture1, uv)
        const tex2 = texture(texture2, uv)
        // Procedural gradient mask
        const gradient = uv.x // Left to right gradient
        // Smooth boundary
        const smoothGradient = smoothstep(0.2, 0.8, gradient)
        const blendedColor = mix(tex1, tex2, smoothGradient)
        return blendedColor
}`}
/>

## Dynamic Texture Effects

### Texture Scrolling

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://avatars.githubusercontent.com/u/40712342')
        // Scroll speed
        const scrollSpeed = vec2(float(0.1), float(0.05))
        // Time-based offset
        const offset = iTime.mul(scrollSpeed)
        uv = uv.add(offset)
        const textureColor = texture(iTexture, fract(uv))
        return textureColor
}`}
/>

### Wavy Texture

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://avatars.githubusercontent.com/u/40712342')
        // Distortion by waves
        const waveAmplitude = float(05)
        const waveFrequency = float(8)
        const waveSpeed = float(2)
        const waveX = sin(uv.y.mul(waveFrequency).add(iTime.mul(waveSpeed))).mul(waveAmplitude)
        const waveY = sin(uv.x.mul(waveFrequency).add(iTime.mul(waveSpeed))).mul(waveAmplitude)
        uv = uv.add(vec2(waveX, waveY))
        const textureColor = texture(iTexture, uv)
        return textureColor
}`}
/>

### Particle Texture

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const iTexture = uniform('https://picsum.photos/512/512?random=4')
        
        // Particle layer generation function
        const generateParticleLayers = Fn(([uv, time]) => {
                let finalColor = vec4(0)
                // Multiple particle layers
                Loop(3, ({ layer }) => {
                        const layerFloat = float(layer)
                        // Settings for each layer
                        const scale = layerFloat.add(float(1)).mul(float(2))
                        const speed = layerFloat.mul(float(0.3)).add(float(0.1))
                        // Scrolling
                        const scrollOffset = vec2(float(0), time.mul(speed))
                        let layerUV = uv.mul(scale).add(scrollOffset)
                        layerUV = fract(layerUV)
                        // Texture sampling
                        const layerColor = texture(iTexture, layerUV)
                        // Blending
                        const alpha = layerColor.a.mul(float(0.3)).div(layerFloat.add(float(1)))
                        finalColor.assign(finalColor.add(layerColor.mul(alpha)))
                })
                return finalColor
        })
        
        // Generate particle layers
        const finalColor = generateParticleLayers(uv, iTime)
        return finalColor
}`}
/>

## Texture Creation Techniques

### Procedural Texture

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Wood grain pattern
        const rings = sin(length(uv.sub(0.5)).mul(50))
                .mul(0.5)
                .add(0.5)
        const grain = sin(uv.x.mul(200)).mul(sin(uv.y.mul(180)))
        const woodPattern = rings.add(grain.mul(0.1))
        // Wood color tone
        const woodColor = vec3(0.6, 0.4, 0.2).mul(woodPattern)
        return vec4(woodColor, 1)
}`}
/>

### Noise Texture

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Simple noise function
        const noise = Fn(([uv]) => {
                return fract(sin(dot(uv, vec2(12.9898, 78.233))).mul(43758.5453))
        })
        
        // Multi-octave noise generation function
        const generateMultiOctaveNoise = Fn(([uv]) => {
                let noiseValue = float(0)
                let amplitude = float(0.5)
                let frequency = float(2)
                Loop(int(6), ({ i }) => {
                        noiseValue.assign(noiseValue.add(noise(uv.mul(frequency)).mul(amplitude)))
                        amplitude.assign(amplitude.mul(0.5))
                        frequency.assign(frequency.mul(2))
                })
                return noiseValue
        })
        
        // Generate multi-octave noise
        const noiseValue = generateMultiOctaveNoise(uv)
        const color = vec3(noiseValue)
        return vec4(color, 1)
}`}
/>

## Next Steps

Once you've mastered image and texture manipulation, next learn about [Interactive Effects](06-interactive-effects.md) to create effects that respond to user interactions.

What you learned in this tutorial:

- ✅ Image loading and UV coordinates
- ✅ Image filters (blur, edge detection, sepia)
- ✅ Texture coordinate manipulation
- ✅ Multi-texture composition
- ✅ Dynamic texture effects
- ✅ Procedural texture creation

In the next chapter, you'll learn about interactive visual expressions that respond to mouse and keyboard operations.
