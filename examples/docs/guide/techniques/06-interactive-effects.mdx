# Interactive Effects

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

Create visual expressions that respond to mouse and keyboard interactions.

## Interaction Basics

<Tabs>
<TabItem value="mouse" label="Mouse Operations">

```jsx live
function Canvas() {
        // Distance from mouse position
        const mousePos = iMouse.add(0.5)
        const distance = uv.sub(mousePos).length()
        // Click state
        const clicking = uniform(0, 'isClicking')
        // Color based on distance (enhanced when clicking)
        const clickingFactor = clicking.add(1)
        const intensity = distance.oneMinus().mul(clickingFactor)
        const color = vec3(1, 0.8, 1.2).mul(intensity)

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1)
        })

        // Use rege's useDrag (click detection)
        const dragState = useDrag((state) => {
                if (state.isDragStart) {
                        gl.uniform('isClicking', 1)
                } else if (state.isDragEnd) {
                        gl.uniform('isClicking', 0)
                }
        })

        // Use rege's useHover (mouse position tracking)
        const hoverState = useHover((state) => {
                if (state.isHovering) {
                        const [width, height] = gl.size
                        const value = state.value ? state.value : [0, 0]
                        const normalizedMouse = [
                                (value[0] / width) * 2 - 1,
                                -(value[1] / height) * 2 - 1
                        ]
                        gl.uniform('iMouse', normalizedMouse)
                }
        })

        return <canvas ref={(el) => {
                gl.ref(el)
                dragState.ref(el)
                hoverState.ref(el)
        }} />
```

</TabItem>
<TabItem value="keyboard" label="Keyboard Operations">

```jsx live
function Canvas() {
        const colorMode = uniform(vec3(0), 'colorMode')
        const frequency = uniform(5, 'frequency')

        // Color changes based on key input
        const baseColor = vec3(0.3, 0.3, 0.5)
        const redBoost = step(0.5, colorMode.x) // 'R' key
        const greenBoost = step(0.5, colorMode.y) // 'G' key
        const blueBoost = step(0.5, colorMode.z) // 'B' key

        const color = vec3(
                const redComponent = baseColor.r.add(redBoost.mul(0.7))
                redComponent,
                const greenComponent = baseColor.g.add(greenBoost.mul(0.7))
                greenComponent,
                const blueComponent = baseColor.b.add(blueBoost.mul(0.7))
                blueComponent
        )

        // Pattern drawing (frequency adjustment with arrow keys)
        const patternX = position.x.mul(frequency).sin()
        const patternY = position.y.mul(frequency).sin()
        const pattern = patternX.mul(patternY)
        const patternOffset = pattern.add(0.5)
        const finalColor = color.mul(patternOffset)

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(finalColor, 1),
        })

        // Use rege's useKey
        let pressedKeys = new Set()
        let currentFreq = 5

        const updateUniforms = () => {
                const colorMode = [
                        pressedKeys.has('KeyR') ? 1 : 0,
                        pressedKeys.has('KeyG') ? 1 : 0,
                        pressedKeys.has('KeyB') ? 1 : 0,
                ]
                gl.uniform('colorMode', colorMode)
                gl.uniform('frequency', currentFreq)
        }

        const keyState = useKey((state) => {
                if (state.event && state.event.type === 'keydown') {
                        pressedKeys.add(state.code)

                        // Frequency adjustment with arrow keys
                        if (state.code === 'ArrowUp') {
                                currentFreq = Math.min(currentFreq + 1, 20)
                        }
                        if (state.code === 'ArrowDown') {
                                currentFreq = Math.max(currentFreq - 1, 1)
                        }

                        updateUniforms()
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                keyState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
<TabItem value="drag" label="Drag Operations">

```jsx live
function Canvas() {
        const dragVector = uniform(vec2(0), 'dragVector')
        const isDragging = uniform(0, 'isDragging')

        // Distortion by drag vector
        const distortion = dragVector.mul(0.8)
        const distortedPos = position.xy.add(distortion)

        // Pattern with distorted coordinates
        const pattern1 = distortedPos.x.mul(8).sin()
        const pattern2 = distortedPos.y.mul(8).sin()
        const finalPattern = pattern1.mul(pattern2)

        // Change color based on drag strength and state
        const dragStrength = dragVector.length()
        const dragEffect = isDragging.mul(0.5).add(1)
        const color = vec3(
                finalPattern.add(0.5).mul(dragEffect),
                const pattern1 = finalPattern.add(0.5).mul(dragStrength.oneMinus()).mul(dragEffect)
                pattern1,
                const pattern2 = finalPattern.add(0.5).oneMinus().mul(dragStrength.add(0.3)).mul(dragEffect)
                pattern2
        )

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1),
        })

        // Use rege's useDrag (mouse + touch auto-support)
        const dragState = useDrag((state) => {
                if (state.isDragStart) {
                        gl.uniform('isDragging', 1)
                } else if (state.isDragging) {
                        // state.movement is cumulative movement
                        const [width, height] = gl.size
                        const movement = state.movement || [0, 0]
                        const normalizedMovement = [
                                (movement[0] / width) * 4, // Sensitivity adjustment
                                -(movement[1] / height) * 4,
                        ]
                        gl.uniform('dragVector', normalizedMovement)
                } else if (state.isDragEnd) {
                        gl.uniform('isDragging', 0)
                        gl.uniform('dragVector', [0, 0])
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                dragState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
</Tabs>

## Advanced Interactions

<Tabs>
<TabItem value="touch" label="Touch Operations">

```jsx live
function Canvas() {
        const pinchCenter = uniform(vec2(0), 'pinchCenter')
        const pinchScale = uniform(1, 'pinchScale')
        const isActive = uniform(0, 'isActive')

        // Zoom effect by pinch
        const scaledPos = position.xy.sub(pinchCenter).mul(pinchScale).add(pinchCenter)

        // Pattern drawing
        const patternX = scaledPos.x.mul(8).sin()
        const patternY = scaledPos.y.mul(8).sin()
        const pattern = patternX.mul(patternY)

        // Color change when pinch is active
        const activeEffect = isActive.mul(0.5).add(1)
        const color = vec3(
                pattern.add(0.5).mul(activeEffect),
                pattern.add(0.5).mul(0.8).mul(activeEffect),
                pattern.add(0.5).oneMinus().mul(activeEffect)
        )

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1),
        })

        // Use rege's usePinch (multi-touch support)
        const pinchState = usePinch((state) => {
                if (state.isPinchStart) {
                        gl.uniform('isActive', 1)
                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const center = [(value[0] / width) * 2 - 1, -(value[1] / height) * 2 - 1]
                        gl.uniform('pinchCenter', center)
                } else if (state.isPinching) {
                        // state.scale is 2-element array [scaleX, scaleY]
                        const scale = state.scale || [1, 1]
                        const scaleValue = Math.min(scale[0], scale[1])
                        const minScale = Math.min(3.0, scaleValue)
                        const clampedScale = Math.max(0.5, minScale)
                        gl.uniform('pinchScale', clampedScale)

                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const center = [(value[0] / width) * 2 - 1, -(value[1] / height) * 2 - 1]
                        gl.uniform('pinchCenter', center)
                } else if (state.isPinchEnd) {
                        gl.uniform('isActive', 0)
                        gl.uniform('pinchScale', 1)
                        gl.uniform('pinchCenter', [0, 0])
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                pinchState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
<TabItem value="sensor" label="Device Sensors">

```jsx live
function Canvas() {
        const accel = uniform(vec3(0, -1, 0), 'acceleration')
        const rotation = uniform(0, 'rotation')

        // Effect based on gravity direction
        const gravity = accel.normalize()
        const gravityEffect = dot(position.xy, gravity.xy)

        // Coordinate transformation by device rotation
        const angle = rotation.mul(0.01)
        const cosA = angle.cos()
        const sinA = angle.sin()
        const rotateMat = mat2(cosA, sinA, sinA.negate(), cosA)
        const rotatePos = rotateMat.mul(position.xy)

        // Combination of gravity and pattern
        const patternX = rotatePos.x.mul(8).sin()
        const patternY = rotatePos.y.mul(8).sin()
        const pattern = patternX.mul(patternY)
        const colorR = gravityEffect.add(0.5).mul(pattern.add(0.5))
        const colorG = gravityEffect.abs().mul(pattern.add(0.5))
        const colorB = gravityEffect.oneMinus().add(0.5).mul(pattern.add(0.5))
        const color = vec3(colorR, colorG, colorB)

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1),
        })

        // Device sensor event setup
        React.useEffect(() => {
                // Acceleration sensor
                const handleDeviceMotion = (event) => {
                        const accel = event.accelerationIncludingGravity
                        if (accel) {
                                gl.uniform('acceleration', [accel.x || 0, accel.y || -1, accel.z || 0])
                        }
                }

                // Gyroscope
                const handleDeviceOrientation = (event) => {
                        gl.uniform('rotation', event.gamma || 0)
                }

                if ('DeviceMotionEvent' in window) {
                        window.addEventListener('devicemotion', handleDeviceMotion)
                }

                if ('DeviceOrientationEvent' in window) {
                        window.addEventListener('deviceorientation', handleDeviceOrientation)
                }

                return () => {
                        window.removeEventListener('devicemotion', handleDeviceMotion)
                        window.removeEventListener('deviceorientation', handleDeviceOrientation)
                }
        }, [gl])

        return <canvas ref={gl.ref} />
}
```

</TabItem>
<TabItem value="particles" label="Particle System">

```jsx live
function Canvas() {
        const mouse = uniform(vec2(0), 'mouse')
        const isHovering = uniform(0, 'isHovering')

        // Particle effect from mouse position
        const mouseDistance = position.xy.sub(mouse).length()
        const mouseEffect = smoothstep(0.8, 0.2, mouseDistance)

        // Dynamic pattern
        const time = iTime
        const waveX = position.x.mul(5).add(time).sin()
        const timeOffset = time.mul(0.7)
        const waveYPhase = position.y.mul(5).add(timeOffset)
        const waveY = waveYPhase.sin()
        const wave = waveX.mul(waveY)
        const pulseEffect = time.mul(2).sin().mul(0.5).add(0.5)

        // Enhancement by hover state
        const hoverBoost = isHovering.mul(0.5).add(1)

        // Color composition
        const baseColor = vec3(0.05, 0.05, 0.2)
        const waveOffset = wave.add(0.5)
        const waveColor = vec3(waveOffset).mul(0.3).mul(hoverBoost)
        const mouseG = mouseEffect.mul(0.7)
        const mouseB = mouseEffect.mul(1.3)
        const mouseColor = vec3(mouseEffect, mouseG, mouseB).mul(pulseEffect).mul(hoverBoost)
        const finalColor = baseColor.add(waveColor).add(mouseColor)

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(finalColor, 1),
        })

        // Use rege's useHover (mouse + touch support)
        const hoverState = useHover((state) => {
                if (state.isHoverStart) {
                        gl.uniform('isHovering', 1)
                } else if (state.isHovering) {
                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const normalizedMouse = [(value[0] / width) * 2 - 1, -(value[1] / height) * 2 - 1]
                        gl.uniform('mouse', normalizedMouse)
                } else if (state.isHoverEnd) {
                        gl.uniform('isHovering', 0)
                        gl.uniform('mouse', [0, 0])
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                hoverState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
</Tabs>

## Next Steps

Once you've mastered interactive expressions, you have completed the fundamentals of GLRE visual programming!

What you learned in this tutorial:

- ✅ **Basic Interactions**: Mouse, keyboard, drag operations
- ✅ **Advanced Operations**: Touch, device sensors, particle systems
- ✅ **Implementation Patterns**: Integrated management with useGL mount events

In the next chapter, you'll learn about expressions in 3D space and how to manipulate three-dimensional objects.
