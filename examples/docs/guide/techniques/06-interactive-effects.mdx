# Interactive Effects

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

マウスやキーボードの操作に反応するビジュアル表現を作成しましょう。

## インタラクション基礎

<Tabs>
<TabItem value="mouse" label="マウス操作">

```jsx live
function Canvas() {
        // マウス位置からの距離
        const distance = length(uv.sub(iMouse.add(0.5)))
        // クリック状態
        const clicking = uniform(0, 'isClicking')
        // 距離に応じた色（クリック時強化）
        const intensity = oneMinus(distance).mul(clicking.add(1))
        const color = vec3(intensity, intensity.mul(0.8), intensity.mul(1.2))

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1)
        })

        // regeのuseDragを使用（クリック検出）
        const dragState = useDrag((state) => {
                if (state.isDragStart) {
                        gl.uniform('isClicking', 1)
                } else if (state.isDragEnd) {
                        gl.uniform('isClicking', 0)
                }
        })

        // regeのuseHoverを使用（マウス位置追跡）
        const hoverState = useHover((state) => {
                if (state.isHovering) {
                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const normalizedMouse = [
                                (value[0] / width) * 2 - 1,
                                -(value[1] / height) * 2 - 1
                        ]
                        gl.uniform('iMouse', normalizedMouse)
                }
        })

        return <canvas ref={(el) => {
                gl.ref(el)
                dragState.ref(el)
                hoverState.ref(el)
        }} />
```

</TabItem>
<TabItem value="keyboard" label="キーボード操作">

```jsx live
function Canvas() {
        const colorMode = uniform(vec3(0), 'colorMode')
        const frequency = uniform(5, 'frequency')

        // キー入力に応じた色の変更
        const baseColor = vec3(0.3, 0.3, 0.5)
        const redBoost = step(0.5, colorMode.x) // 'R'キー
        const greenBoost = step(0.5, colorMode.y) // 'G'キー
        const blueBoost = step(0.5, colorMode.z) // 'B'キー

        const color = vec3(
                baseColor.r.add(redBoost.mul(0.7)),
                baseColor.g.add(greenBoost.mul(0.7)),
                baseColor.b.add(blueBoost.mul(0.7))
        )

        // パターンの描画（矢印キーで周波数調整）
        const pattern = sin(position.x.mul(frequency)).mul(sin(position.y.mul(frequency)))
        const finalColor = color.mul(pattern.add(0.5))

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(finalColor, 1),
        })

        // regeのuseKeyを使用
        let pressedKeys = new Set()
        let currentFreq = 5

        const updateUniforms = () => {
                const colorMode = [
                        pressedKeys.has('KeyR') ? 1 : 0,
                        pressedKeys.has('KeyG') ? 1 : 0,
                        pressedKeys.has('KeyB') ? 1 : 0,
                ]
                gl.uniform('colorMode', colorMode)
                gl.uniform('frequency', currentFreq)
        }

        const keyState = useKey((state) => {
                if (state.event && state.event.type === 'keydown') {
                        pressedKeys.add(state.code)

                        // 矢印キーで周波数調整
                        if (state.code === 'ArrowUp') {
                                currentFreq = Math.min(currentFreq + 1, 20)
                        }
                        if (state.code === 'ArrowDown') {
                                currentFreq = Math.max(currentFreq - 1, 1)
                        }

                        updateUniforms()
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                keyState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
<TabItem value="drag" label="ドラッグ操作">

```jsx live
function Canvas() {
        const dragVector = uniform(vec2(0), 'dragVector')
        const isDragging = uniform(0, 'isDragging')

        // ドラッグベクトルによる歪み
        const distortion = dragVector.mul(0.8)
        const distortedPos = position.xy.add(distortion)

        // 歪んだ座標でのパターン
        const pattern1 = sin(distortedPos.x.mul(8))
        const pattern2 = sin(distortedPos.y.mul(8))
        const finalPattern = pattern1.mul(pattern2)

        // ドラッグの強度と状態で色を変化
        const dragStrength = length(dragVector)
        const dragEffect = isDragging.mul(0.5).add(1)
        const color = vec3(
                finalPattern.add(0.5).mul(dragEffect),
                finalPattern.add(0.5).mul(oneMinus(dragStrength)).mul(dragEffect),
                oneMinus(finalPattern.add(0.5)).mul(dragStrength.add(0.3)).mul(dragEffect)
        )

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1),
        })

        // regeのuseDragを使用（マウス＋タッチ自動対応）
        const dragState = useDrag((state) => {
                if (state.isDragStart) {
                        gl.uniform('isDragging', 1)
                } else if (state.isDragging) {
                        // state.movement は累積的な移動量
                        const [width, height] = gl.size
                        const movement = state.movement || [0, 0]
                        const normalizedMovement = [
                                (movement[0] / width) * 4, // 感度調整
                                -(movement[1] / height) * 4,
                        ]
                        gl.uniform('dragVector', normalizedMovement)
                } else if (state.isDragEnd) {
                        gl.uniform('isDragging', 0)
                        gl.uniform('dragVector', [0, 0])
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                dragState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
</Tabs>

## 応用インタラクション

<Tabs>
<TabItem value="touch" label="タッチ操作">

```jsx live
function Canvas() {
        const pinchCenter = uniform(vec2(0), 'pinchCenter')
        const pinchScale = uniform(1, 'pinchScale')
        const isActive = uniform(0, 'isActive')

        // ピンチによるズーム効果
        const scaledPos = position.xy.sub(pinchCenter).mul(pinchScale).add(pinchCenter)

        // パターンの描画
        const pattern = sin(scaledPos.x.mul(8)).mul(sin(scaledPos.y.mul(8)))

        // ピンチアクティブ時の色変化
        const activeEffect = isActive.mul(0.5).add(1)
        const color = vec3(
                pattern.add(0.5).mul(activeEffect),
                pattern.add(0.5).mul(0.8).mul(activeEffect),
                oneMinus(pattern.add(0.5)).mul(activeEffect)
        )

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1),
        })

        // regeのusePinchを使用（マルチタッチ対応）
        const pinchState = usePinch((state) => {
                if (state.isPinchStart) {
                        gl.uniform('isActive', 1)
                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const center = [(value[0] / width) * 2 - 1, -(value[1] / height) * 2 - 1]
                        gl.uniform('pinchCenter', center)
                } else if (state.isPinching) {
                        // state.scale は2要素配列 [scaleX, scaleY]
                        const scale = state.scale || [1, 1]
                        const scaleValue = Math.min(scale[0], scale[1])
                        gl.uniform('pinchScale', Math.max(0.5, Math.min(3.0, scaleValue)))

                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const center = [(value[0] / width) * 2 - 1, -(value[1] / height) * 2 - 1]
                        gl.uniform('pinchCenter', center)
                } else if (state.isPinchEnd) {
                        gl.uniform('isActive', 0)
                        gl.uniform('pinchScale', 1)
                        gl.uniform('pinchCenter', [0, 0])
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                pinchState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
<TabItem value="sensor" label="デバイスセンサー">

```jsx live
function Canvas() {
        const accel = uniform(vec3(0, -1, 0), 'acceleration')
        const rotation = uniform(0, 'rotation')

        // 重力方向による効果
        const gravity = normalize(accel)
        const gravityEffect = dot(position.xy, gravity.xy)

        // デバイス回転による座標変換
        const angle = rotation.mul(0.01)
        const cosA = cos(angle)
        const sinA = sin(angle)
        const rotatedPos = vec2(
                position.x.mul(cosA).sub(position.y.mul(sinA)),
                position.x.mul(sinA).add(position.y.mul(cosA))
        )

        // 重力とパターンの組み合わせ
        const pattern = sin(rotatedPos.x.mul(8)).mul(sin(rotatedPos.y.mul(8)))
        const color = vec3(
                gravityEffect.add(0.5).mul(pattern.add(0.5)),
                abs(gravityEffect).mul(pattern.add(0.5)),
                oneMinus(gravityEffect).add(0.5).mul(pattern.add(0.5))
        )

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1),
        })

        // デバイスセンサーイベントの設定
        React.useEffect(() => {
                // 加速度センサー
                const handleDeviceMotion = (event) => {
                        const accel = event.accelerationIncludingGravity
                        if (accel) {
                                gl.uniform('acceleration', [accel.x || 0, accel.y || -1, accel.z || 0])
                        }
                }

                // ジャイロスコープ
                const handleDeviceOrientation = (event) => {
                        gl.uniform('rotation', event.gamma || 0)
                }

                if ('DeviceMotionEvent' in window) {
                        window.addEventListener('devicemotion', handleDeviceMotion)
                }

                if ('DeviceOrientationEvent' in window) {
                        window.addEventListener('deviceorientation', handleDeviceOrientation)
                }

                return () => {
                        window.removeEventListener('devicemotion', handleDeviceMotion)
                        window.removeEventListener('deviceorientation', handleDeviceOrientation)
                }
        }, [gl])

        return <canvas ref={gl.ref} />
}
```

</TabItem>
<TabItem value="particles" label="パーティクルシステム">

```jsx live
function Canvas() {
        const mouse = uniform(vec2(0), 'mouse')
        const isHovering = uniform(0, 'isHovering')

        // マウス位置からのパーティクル効果
        const mouseDistance = length(position.xy.sub(mouse))
        const mouseEffect = smoothstep(0.8, 0.2, mouseDistance)

        // 動的なパターン
        const time = iTime
        const wave = sin(position.x.mul(5).add(time)).mul(sin(position.y.mul(5).add(time.mul(0.7))))
        const pulseEffect = sin(time.mul(2)).mul(0.5).add(0.5)

        // ホバー状態による強化
        const hoverBoost = isHovering.mul(0.5).add(1)

        // 色の合成
        const baseColor = vec3(0.05, 0.05, 0.2)
        const waveColor = vec3(wave.add(0.5)).mul(0.3).mul(hoverBoost)
        const mouseColor = vec3(mouseEffect, mouseEffect.mul(0.7), mouseEffect.mul(1.3))
                .mul(pulseEffect)
                .mul(hoverBoost)
        const finalColor = baseColor.add(waveColor).add(mouseColor)

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(finalColor, 1),
        })

        // regeのuseHoverを使用（マウス＋タッチ対応）
        const hoverState = useHover((state) => {
                if (state.isHoverStart) {
                        gl.uniform('isHovering', 1)
                } else if (state.isHovering) {
                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const normalizedMouse = [(value[0] / width) * 2 - 1, -(value[1] / height) * 2 - 1]
                        gl.uniform('mouse', normalizedMouse)
                } else if (state.isHoverEnd) {
                        gl.uniform('isHovering', 0)
                        gl.uniform('mouse', [0, 0])
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                hoverState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
</Tabs>

## 次のステップ

インタラクティブな表現をマスターしたら、次は[3D 表現と空間](../advanced/07-3d-graphics.mdx)で、立体的なビジュアルを学びましょう。

このチュートリアルで学んだこと：

- ✅ **基礎インタラクション**: マウス、キーボード、ドラッグ操作
- ✅ **応用操作**: タッチ、デバイスセンサー、パーティクルシステム
- ✅ **実装パターン**: useGL の mount イベントによる統合管理

次の章では、3 次元空間での表現や立体的なオブジェクトの操作方法を学習します。
