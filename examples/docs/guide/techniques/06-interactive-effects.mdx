# Interactive Effects

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

Create visual expressions that respond to mouse and keyboard interactions.

## Interaction Basics

<Tabs>
<TabItem value="mouse" label="Mouse Operations">

```jsx live
function Canvas() {
        // Distance from mouse position
        const distance = length(uv.sub(iMouse.add(0.5)))
        // Click state
        const clicking = uniform(0, 'isClicking')
        // Color based on distance (enhanced when clicking)
        const intensity = oneMinus(distance).mul(clicking.add(1))
        const color = vec3(intensity, intensity.mul(0.8), intensity.mul(1.2))

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1)
        })

        // Use rege's useDrag (click detection)
        const dragState = useDrag((state) => {
                if (state.isDragStart) {
                        gl.uniform('isClicking', 1)
                } else if (state.isDragEnd) {
                        gl.uniform('isClicking', 0)
                }
        })

        // Use rege's useHover (mouse position tracking)
        const hoverState = useHover((state) => {
                if (state.isHovering) {
                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const normalizedMouse = [
                                (value[0] / width) * 2 - 1,
                                -(value[1] / height) * 2 - 1
                        ]
                        gl.uniform('iMouse', normalizedMouse)
                }
        })

        return <canvas ref={(el) => {
                gl.ref(el)
                dragState.ref(el)
                hoverState.ref(el)
        }} />
```

</TabItem>
<TabItem value="keyboard" label="Keyboard Operations">

```jsx live
function Canvas() {
        const colorMode = uniform(vec3(0), 'colorMode')
        const frequency = uniform(5, 'frequency')

        // Color changes based on key input
        const baseColor = vec3(0.3, 0.3, 0.5)
        const redBoost = step(0.5, colorMode.x) // 'R' key
        const greenBoost = step(0.5, colorMode.y) // 'G' key
        const blueBoost = step(0.5, colorMode.z) // 'B' key

        const color = vec3(
                baseColor.r.add(redBoost.mul(0.7)),
                baseColor.g.add(greenBoost.mul(0.7)),
                baseColor.b.add(blueBoost.mul(0.7))
        )

        // Pattern drawing (frequency adjustment with arrow keys)
        const pattern = sin(position.x.mul(frequency)).mul(sin(position.y.mul(frequency)))
        const finalColor = color.mul(pattern.add(0.5))

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(finalColor, 1),
        })

        // Use rege's useKey
        let pressedKeys = new Set()
        let currentFreq = 5

        const updateUniforms = () => {
                const colorMode = [
                        pressedKeys.has('KeyR') ? 1 : 0,
                        pressedKeys.has('KeyG') ? 1 : 0,
                        pressedKeys.has('KeyB') ? 1 : 0,
                ]
                gl.uniform('colorMode', colorMode)
                gl.uniform('frequency', currentFreq)
        }

        const keyState = useKey((state) => {
                if (state.event && state.event.type === 'keydown') {
                        pressedKeys.add(state.code)

                        // Frequency adjustment with arrow keys
                        if (state.code === 'ArrowUp') {
                                currentFreq = Math.min(currentFreq + 1, 20)
                        }
                        if (state.code === 'ArrowDown') {
                                currentFreq = Math.max(currentFreq - 1, 1)
                        }

                        updateUniforms()
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                keyState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
<TabItem value="drag" label="Drag Operations">

```jsx live
function Canvas() {
        const dragVector = uniform(vec2(0), 'dragVector')
        const isDragging = uniform(0, 'isDragging')

        // Distortion by drag vector
        const distortion = dragVector.mul(0.8)
        const distortedPos = position.xy.add(distortion)

        // Pattern with distorted coordinates
        const pattern1 = sin(distortedPos.x.mul(8))
        const pattern2 = sin(distortedPos.y.mul(8))
        const finalPattern = pattern1.mul(pattern2)

        // Change color based on drag strength and state
        const dragStrength = length(dragVector)
        const dragEffect = isDragging.mul(0.5).add(1)
        const color = vec3(
                finalPattern.add(0.5).mul(dragEffect),
                finalPattern.add(0.5).mul(oneMinus(dragStrength)).mul(dragEffect),
                oneMinus(finalPattern.add(0.5)).mul(dragStrength.add(0.3)).mul(dragEffect)
        )

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1),
        })

        // Use rege's useDrag (mouse + touch auto-support)
        const dragState = useDrag((state) => {
                if (state.isDragStart) {
                        gl.uniform('isDragging', 1)
                } else if (state.isDragging) {
                        // state.movement is cumulative movement
                        const [width, height] = gl.size
                        const movement = state.movement || [0, 0]
                        const normalizedMovement = [
                                (movement[0] / width) * 4, // Sensitivity adjustment
                                -(movement[1] / height) * 4,
                        ]
                        gl.uniform('dragVector', normalizedMovement)
                } else if (state.isDragEnd) {
                        gl.uniform('isDragging', 0)
                        gl.uniform('dragVector', [0, 0])
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                dragState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
</Tabs>

## Advanced Interactions

<Tabs>
<TabItem value="touch" label="Touch Operations">

```jsx live
function Canvas() {
        const pinchCenter = uniform(vec2(0), 'pinchCenter')
        const pinchScale = uniform(1, 'pinchScale')
        const isActive = uniform(0, 'isActive')

        // Zoom effect by pinch
        const scaledPos = position.xy.sub(pinchCenter).mul(pinchScale).add(pinchCenter)

        // Pattern drawing
        const pattern = sin(scaledPos.x.mul(8)).mul(sin(scaledPos.y.mul(8)))

        // Color change when pinch is active
        const activeEffect = isActive.mul(0.5).add(1)
        const color = vec3(
                pattern.add(0.5).mul(activeEffect),
                pattern.add(0.5).mul(0.8).mul(activeEffect),
                oneMinus(pattern.add(0.5)).mul(activeEffect)
        )

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1),
        })

        // Use rege's usePinch (multi-touch support)
        const pinchState = usePinch((state) => {
                if (state.isPinchStart) {
                        gl.uniform('isActive', 1)
                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const center = [(value[0] / width) * 2 - 1, -(value[1] / height) * 2 - 1]
                        gl.uniform('pinchCenter', center)
                } else if (state.isPinching) {
                        // state.scale is 2-element array [scaleX, scaleY]
                        const scale = state.scale || [1, 1]
                        const scaleValue = Math.min(scale[0], scale[1])
                        gl.uniform('pinchScale', Math.max(0.5, Math.min(3.0, scaleValue)))

                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const center = [(value[0] / width) * 2 - 1, -(value[1] / height) * 2 - 1]
                        gl.uniform('pinchCenter', center)
                } else if (state.isPinchEnd) {
                        gl.uniform('isActive', 0)
                        gl.uniform('pinchScale', 1)
                        gl.uniform('pinchCenter', [0, 0])
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                pinchState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
<TabItem value="sensor" label="Device Sensors">

```jsx live
function Canvas() {
        const accel = uniform(vec3(0, -1, 0), 'acceleration')
        const rotation = uniform(0, 'rotation')

        // Effect based on gravity direction
        const gravity = normalize(accel)
        const gravityEffect = dot(position.xy, gravity.xy)

        // Coordinate transformation by device rotation
        const angle = rotation.mul(0.01)
        const cosA = cos(angle)
        const sinA = sin(angle)
        const rotatedPos = vec2(
                position.x.mul(cosA).sub(position.y.mul(sinA)),
                position.x.mul(sinA).add(position.y.mul(cosA))
        )

        // Combination of gravity and pattern
        const pattern = sin(rotatedPos.x.mul(8)).mul(sin(rotatedPos.y.mul(8)))
        const color = vec3(
                gravityEffect.add(0.5).mul(pattern.add(0.5)),
                abs(gravityEffect).mul(pattern.add(0.5)),
                oneMinus(gravityEffect).add(0.5).mul(pattern.add(0.5))
        )

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(color, 1),
        })

        // Device sensor event setup
        React.useEffect(() => {
                // Acceleration sensor
                const handleDeviceMotion = (event) => {
                        const accel = event.accelerationIncludingGravity
                        if (accel) {
                                gl.uniform('acceleration', [accel.x || 0, accel.y || -1, accel.z || 0])
                        }
                }

                // Gyroscope
                const handleDeviceOrientation = (event) => {
                        gl.uniform('rotation', event.gamma || 0)
                }

                if ('DeviceMotionEvent' in window) {
                        window.addEventListener('devicemotion', handleDeviceMotion)
                }

                if ('DeviceOrientationEvent' in window) {
                        window.addEventListener('deviceorientation', handleDeviceOrientation)
                }

                return () => {
                        window.removeEventListener('devicemotion', handleDeviceMotion)
                        window.removeEventListener('deviceorientation', handleDeviceOrientation)
                }
        }, [gl])

        return <canvas ref={gl.ref} />
}
```

</TabItem>
<TabItem value="particles" label="Particle System">

```jsx live
function Canvas() {
        const mouse = uniform(vec2(0), 'mouse')
        const isHovering = uniform(0, 'isHovering')

        // Particle effect from mouse position
        const mouseDistance = length(position.xy.sub(mouse))
        const mouseEffect = smoothstep(0.8, 0.2, mouseDistance)

        // Dynamic pattern
        const time = iTime
        const wave = sin(position.x.mul(5).add(time)).mul(sin(position.y.mul(5).add(time.mul(0.7))))
        const pulseEffect = sin(time.mul(2)).mul(0.5).add(0.5)

        // Enhancement by hover state
        const hoverBoost = isHovering.mul(0.5).add(1)

        // Color composition
        const baseColor = vec3(0.05, 0.05, 0.2)
        const waveColor = vec3(wave.add(0.5)).mul(0.3).mul(hoverBoost)
        const mouseColor = vec3(mouseEffect, mouseEffect.mul(0.7), mouseEffect.mul(1.3))
                .mul(pulseEffect)
                .mul(hoverBoost)
        const finalColor = baseColor.add(waveColor).add(mouseColor)

        const gl = useGL({
                width: 512,
                height: 512,
                frag: vec4(finalColor, 1),
        })

        // Use rege's useHover (mouse + touch support)
        const hoverState = useHover((state) => {
                if (state.isHoverStart) {
                        gl.uniform('isHovering', 1)
                } else if (state.isHovering) {
                        const [width, height] = gl.size
                        const value = state.value || [0, 0]
                        const normalizedMouse = [(value[0] / width) * 2 - 1, -(value[1] / height) * 2 - 1]
                        gl.uniform('mouse', normalizedMouse)
                } else if (state.isHoverEnd) {
                        gl.uniform('isHovering', 0)
                        gl.uniform('mouse', [0, 0])
                }
        })

        return (
                <canvas
                        ref={(el) => {
                                gl.ref(el)
                                hoverState.ref(el)
                        }}
                />
        )
}
```

</TabItem>
</Tabs>

## Next Steps

Once you've mastered interactive expressions, next learn about [3D Expression and Space](../advanced/07-3d-graphics.mdx) to create three-dimensional visuals.

What you learned in this tutorial:

- ✅ **Basic Interactions**: Mouse, keyboard, drag operations
- ✅ **Advanced Operations**: Touch, device sensors, particle systems
- ✅ **Implementation Patterns**: Integrated management with useGL mount events

In the next chapter, you'll learn about expressions in 3D space and how to manipulate three-dimensional objects.
