# Shapes and Patterns

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

Learn to create various geometric shapes and complex patterns.

## Basic Shapes

### Circle

The most fundamental shape ????:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Distance from center
        const distance = length(uv.sub(0.5))
        // Hard edge circle (aliased)
        const circle = step(distance, 0.3)
        return vec4(vec3(circle), 1)
}`}
/>

### Anti-aliased Circle

Using `fwidth()` for automatic edge smoothing:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Distance from center
        const distance = length(uv.sub(0.5))
        // Anti-aliasing using screen-space derivatives
        const edge = fwidth(distance)
        const circle = smoothstep(edge.add(0.3), edge.sub(0.3).negate(), distance)
        return vec4(vec3(circle), 1)
}`}
/>

### MSAA Circle

Using multi-sampling for superior edge quality:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const msaa = Fn(([AA]) => {
                const pos = uv.sub(0.5)
                const ret = float(0).toVar()
                Loop(int(AA), ({ i: m }) => {
                        Loop(int(AA), ({ i: n }) => {
                                const offset = vec2(float(m), float(n))
                                const diff = offset.div(AA).sub(0.5).div(iResolution)
                                const distance = length(pos.add(diff))
                                const circle = step(distance, 0.3)
                                ret.assign(ret.add(circle))
                        })
                })
                return ret.div(AA.mul(AA))
        })
        return vec4(vec3(msaa(4)), 1)
}`}
/>

## Polygons

### Triangle

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Triangle using polygon generator (keep original function)
        const polygon = (pos, sides, size) => {
                const angle = atan2(pos.y, pos.x)
                const radius = length(pos)
                const pi2 = float(6.28318)
                const a = angle.add(float(3.14159)).div(pi2).mul(sides)
                const r = cos(floor(a).sub(a).add(float(0.5)).mul(pi2).div(sides))
                return step(radius.mul(r), size)
        }
        const triangle = polygon(uv.sub(0.5), 3, 0.2)
        return vec4(vec3(triangle), 1)
}`}
/>

### Regular Polygon

Create any regular polygon:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Function to create polygon
        const pos = uv.sub(0.5)
        const gap = 0.25
        const polygon = (pos, sides, size) => {
                const angle = atan2(pos.y, pos.x)
                const radius = length(pos)
                const pi2 = float(6.28318)
                const a = angle.add(float(3.14159)).div(pi2).mul(sides)
                const r = cos(floor(a).sub(a).add(float(0.5)).mul(pi2).div(sides))
                return step(radius.mul(r), size)
        }
        // Create different polygons with consistent visual size
        const shapes = polygon(pos.add(vec2(-gap, gap)), 3, 0.1)
                .add(polygon(pos.add(vec2(gap, gap)), 4, 0.15))
                .add(polygon(pos.add(vec2(-gap, -gap)), 6, 0.15))
                .add(polygon(pos.add(vec2(gap, -gap)), 8, 0.15))
        return vec4(vec3(shapes), 1)
}`}
/>

### Star Shape

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Pentagram (5-pointed star) using distance field
        const pos = uv.sub(0.5)
        const v1 = constant(vec2(0.809016994, -0.587785252))
        const v2 = constant(vec2(v1.x.negate(), v1.y))
        const v3 = constant(vec2(0.309016994, -0.951056516))
        // SDF Pentagram function by Inigo Quilez
        const sdPentagram = Fn(([p, r]) => {
                let px = abs(p.x)
                let py = p.y
                let d = max(dot(vec2(px, py), v1), 0)
                px = px.sub(d.mul(v1.x).mul(2))
                py = py.sub(d.mul(v1.y).mul(2))
                d = max(dot(vec2(px, py), v2), 0)
                px = px.sub(d.mul(v2.x).mul(2))
                py = py.sub(d.mul(v2.y).mul(2))
                px = abs(px)
                py = py.sub(r)
                const c = clamp(dot(vec2(px, py), v3), 0, float(0.726542528))
                return length(vec2(px, py).sub(v3.mul(c)))
        })
        // Create star
        const starDist = sdPentagram(pos, float(0.2))
        const starShape = smoothstep(0.02, 0, starDist)
        return vec4(vec3(starShape), 1)
}`}
/>

## Lines and Curves

### Straight Lines

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Horizontal line
        let c = smoothstep(0.02, 0, abs(uv.y))
        // Vertical line
        c = c.add(smoothstep(0.02, 0, abs(uv.x)))
        // Diagonal line
        c = c.add(smoothstep(0.02, 0, abs(uv.y.sub(uv.x))))
        return vec4(vec3(c), 1)
}`}
/>

### Curves

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Sine wave
        const pos = uv.sub(0.5).mul(2)
        const sineWave = sin(pos.x.mul(4)).mul(0.3)
        const sineDistance = abs(pos.y.sub(sineWave))
        const sineLine = smoothstep(0.05, 0, sineDistance)
        // Parabola
        const parabola = pow(pos.x, 3)
        const parabolaDistance = abs(pos.y.sub(parabola))
        const parabolaLine = smoothstep(0.05, 0, parabolaDistance)
        // Circle outline
        const circleDistance = abs(length(pos).sub(0.5))
        const circleLine = smoothstep(0.05, 0, circleDistance)
        const curves = max(sineLine, max(parabolaLine, circleLine))
        return vec4(vec3(curves), 1)
}`}
/>

## Complex Patterns

### Fractal-like Pattern

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Create fractal pattern using Loop with configurable iterations
        const generateFractal = Fn(([uv, iterations]) => {
                let color = vec3(0).toVar()
                // Multiple scales of the same pattern
                Loop(int(iterations), ({ i }) => {
                        const layerIndex = float(i)
                        const scale = pow(2, layerIndex)
                        const scaledPos = uv.mul(scale)
                        // Circle pattern at each scale
                        const dist = length(fract(scaledPos).sub(0.5))
                        const circle = smoothstep(0.3, 0.2, dist)
                        // Add to final color with decreasing weight
                        const weight = oneMinus(layerIndex.div(float(iterations)))
                        color.assign(color.add(vec3(circle).mul(weight)))
                })
                return color.div(float(iterations)) // Normalize
        })
        const fractalColor = generateFractal(uv, 8)
        return vec4(fractalColor, 1)
}`}
/>

### Voronoi Pattern

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const st = uv.mul(float(5))
        const row = floor(st)
        const col = fract(st)
        const random2 = Fn(([p]) => {
                return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))).mul(43758.5453))
        })
        const voronoiPattern = Fn(([gridRow, gridCol]) => {
                const minDist = float(1).toVar('minDist')
                const closestPoint = vec2(0).toVar('closestPoint')
                Loop(int(9), ({ i }) => {
                        const idx = i.toFloat()
                        const x = floor(mod(idx, float(3))).sub(1)
                        const y = floor(idx.div(float(3))).sub(1)
                        const offset = vec2(x, y).toVar()
                        const point = random2(gridRow.add(offset)).toVar()
                        const dist = length(offset.add(point).sub(gridCol)).toVar()
                        const closer = step(dist, minDist).toVar()
                        minDist.assign(mix(minDist, dist, closer))
                        closestPoint.assign(mix(closestPoint, point, closer))
                })
                return closestPoint
        })
        const result = voronoiPattern(row, col)
        return vec4(vec3(result, 0.8), 1)
}`}
/>

## Dynamic Patterns

### Game of Life

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const hash = Fn(([coord]) => fract(sin(dot(coord, vec2(127.1, 311.7))).mul(43758.5453)))
        const automata = Fn(([coord, time]) => {
                let neighbors = float(0).toVar('neighbors')
                Loop(int(9), ({ i }) => {
                        const idx = float(i)
                        const x = floor(mod(idx, float(3)))
                        const y = floor(idx.div(float(3)))
                        const offset = vec2(x, y).toVar()
                        If(length(offset).greaterThan(0.1), () => {
                                const cell = step(0.5, hash(coord.add(offset)))
                                neighbors.assign(neighbors.add(cell))
                        })
                })
                const alive = step(0.5, hash(coord.add(time)))
                const birth = step(2.5, neighbors).mul(step(neighbors, 3.5)).mul(oneMinus(alive))
                const survival = step(1.5, neighbors).mul(step(neighbors, 3.5)).mul(alive)
                return max(birth, survival)
        })
        const p = uv.mul(64)
        const local = fract(p)
        const t = floor(iTime)
        const life = automata(floor(p), t)
        const color = length(local)
        return vec4(vec3(color.mul(life)), 1)
}`}
/>

### Morphing Patterns

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Morphing between different patterns
        const t = sin(iTime)
        // Pattern A: Circles
        const circles = sin(length(uv.sub(0.5)).mul(10))
        // Pattern B: Stripes
        const stripes = sin(uv.x.mul(10))
        // Pattern C: Grid
        const grid = sin(uv.x.mul(10)).mul(sin(uv.y.mul(10)))
        // Morph between patterns
        let pattern = mix(circles, stripes, smoothstep(0, 0.33, t))
        pattern = mix(pattern, grid, smoothstep(0.33, 0.66, t))
        pattern = mix(pattern, circles, smoothstep(0.66, 1, t))
        pattern = pattern
        const color = vec3(pattern, pattern.mul(0.8), pattern.mul(1.2))
        return vec4(color, 1)
}`}
/>

## What You've Learned

- ✅ Basic geometric shapes (circles, polygons, stars)
- ✅ Line and curve drawing techniques
- ✅ Grid and tiling patterns
- ✅ Complex pattern generation (fractals, voronoi, moire)
- ✅ Dynamic and animated patterns

## Next Steps

Now that you can create shapes and patterns, learn about [Images and Textures](05-images-textures.md) to work with external images and create complex surface effects.
