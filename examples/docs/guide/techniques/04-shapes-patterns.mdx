# Shapes and Patterns

import { FragmentEditor } from '@site/src/theme/FragmentEditor'

Learn to create various geometric shapes and complex patterns.

## Basic Shapes

### Circle

The most fundamental shape - a perfect circle:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Distance from center
        const distance = length(uv.sub(0.5))
        // Simple circle with hard edge
        const circle = step(distance, 0.5)
        return vec4(vec3(circle), 1)
}`}
/>

### Smooth Circle

Create circles with soft, anti-aliased edges:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const distance = length(uv.sub(0.5))
        // Smooth circle using smoothstep
        const circle = smoothstep(0.5, 0.48, distance)
        // Add gradient effect
        const gradient = oneMinus(distance.mul(2))
        const finalColor = circle.mul(gradient)
        const color = vec3(finalColor, finalColor.mul(0.8), finalColor.mul(1.2))
        return vec4(color, 1)
}`}
/>

### Ellipse

Stretch circles into ellipses:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Different scaling for X and Y
        const aspectRatio = normalize(iResolution)
        const scaledPos = uv.sub(0.5).div(aspectRatio)
        const distance = length(scaledPos)
        const ellipse = smoothstep(0.5, 0.48, distance)
        return vec4(vec3(ellipse), 1)
}`}
/>

## Polygons

### Triangle

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Triangle using polygon generator (smaller size)
        const polygon = (pos, sides, size) => {
                const angle = atan2(pos.y, pos.x)
                const radius = length(pos)
                const pi2 = float(6.28318)
                const a = angle.add(float(3.14159)).div(pi2).mul(sides)
                const r = cos(floor(a).sub(a).add(float(0.5)).mul(pi2).div(sides))
                return step(radius.mul(r), size)
        }
        const triangle = polygon(uv.sub(0.5), float(3), float(0.08))
        return vec4(vec3(triangle), 1)
}`}
/>

### Regular Polygon Generator

Create any regular polygon:

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Function to create polygon
        const polygon = (pos, sides, size) => {
                const angle = atan2(pos.y, pos.x)
                const radius = length(pos)
                const pi2 = float(6.28318)
                const a = angle.add(float(3.14159)).div(pi2).mul(sides)
                const r = cos(floor(a).sub(a).add(float(0.5)).mul(pi2).div(sides))
                return step(radius.mul(r), size)
        }
        // Create different polygons with consistent visual size
        const triangle = polygon(uv.sub(0.5).add(vec2(-0.3, 0.3)), 3, 0.1)
        const square = polygon(uv.sub(0.5).add(vec2(0.3, 0.3)), 4, 0.15)
        const hexagon = polygon(uv.sub(0.5).add(vec2(-0.3, -0.3)), 6, 0.15)
        const octagon = polygon(uv.sub(0.5).add(vec2(0.3, -0.3)), 8, 0.15)
        const shapes = triangle.add(square).add(hexagon).add(octagon)
        return vec4(vec3(shapes), 1)
}`}
/>

### Star Shape

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Pentagram (5-pointed star) using distance field
        const pos = uv.sub(0.5)
        // SDF Pentagram function by Inigo Quilez
        const sdPentagram = Fn(([p, r]) => {
                const k1x = float(0.809016994) // cos(π/5) = ¼(√5+1)
                const k2x = float(0.309016994) // sin(π/10) = ¼(√5-1)
                const k1y = float(0.587785252) // sin(π/5) = ¼√(10-2√5)
                const k2y = float(0.951056516) // cos(π/10) = ¼√(10+2√5)
                const k1z = float(0.726542528) // tan(π/5) = √(5-2√5)
                const v1 = vec2(k1x, k1y.negate())
                const v2 = vec2(k1x.negate(), k1y.negate())
                const v3 = vec2(k2x, k2y.negate())
                let px = abs(p.x)
                let py = p.y
                // Apply transformations
                const dot1 = max(px.mul(v1.x).add(py.mul(v1.y)), 0)
                px = px.sub(dot1.mul(v1.x).mul(2))
                py = py.sub(dot1.mul(v1.y).mul(2))
                const dot2 = max(px.mul(v2.x).add(py.mul(v2.y)), 0)
                px = px.sub(dot2.mul(v2.x).mul(2))
                py = py.sub(dot2.mul(v2.y).mul(2))
                px = abs(px)
                py = py.sub(r)
                const clampVal = clamp(px.mul(v3.x).add(py.mul(v3.y)), 0, k1z.mul(r))
                const finalX = px.sub(v3.x.mul(clampVal))
                const finalY = py.sub(v3.y.mul(clampVal))
                return length(vec2(finalX, finalY))
        })
        // Create star
        const starDist = sdPentagram(pos, float(0.2))
        const starShape = smoothstep(0.02, 0, starDist)
        return vec4(vec3(starShape), 1)
}`}
/>

## Lines and Curves

### Straight Lines

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Horizontal line
        const horizontalLine = smoothstep(0.02, 0, abs(uv.y))
        // Vertical line
        const verticalLine = smoothstep(0.02, 0, abs(uv.x))
        // Diagonal line
        const diagonalLine = smoothstep(0.02, 0, abs(uv.y.sub(uv.x)))
        const lines = max(horizontalLine, max(verticalLine, diagonalLine))
        return vec4(vec3(lines), 1)
}`}
/>

### Curves

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Sine wave
        const sineWave = sin(uv.sub(0.5).x.mul(4)).mul(0.3)
        const sineDistance = abs(uv.sub(0.5).y.sub(sineWave))
        const sineLine = smoothstep(0.05, 0, sineDistance)
        // Parabola
        const parabola = uv.sub(0.5).x.mul(uv.sub(0.5).x).mul(2)
        const parabolaDistance = abs(uv.sub(0.5).y.sub(parabola))
        const parabolaLine = smoothstep(0.05, 0, parabolaDistance)
        // Circle outline
        const circleDistance = abs(length(uv.sub(0.5)).sub(0.5))
        const circleLine = smoothstep(0.05, 0, circleDistance)
        const curves = max(sineLine, max(parabolaLine, circleLine))
        return vec4(vec3(curves), 1)
}`}
/>

## Pattern Generation

### Grid Pattern

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Grid size and line width
        const gridSize = 8
        const lineWidth = 0.1
        // Grid coordinates
        const gridPos = fract(uv.mul(gridSize))
        // Grid lines
        const lines = smoothstep(0, lineWidth, min(gridPos.x, gridPos.y))
        const grid = oneMinus(lines)
        return vec4(vec3(grid), 1)
}`}
/>

### Hexagonal Grid

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Hexagon distance function
        const hexagon = (p) => {
                let pos = abs(p)
                pos = pos.sub(vec2(0.866, 0.5).mul(max(0, pos.x.sub(pos.y.mul(0.577)))))
                pos = pos.sub(vec2(0.866, 0.5).mul(max(0, dot(pos, vec2(0.866, 0.5)))))
                pos = pos.sub(vec2(clamp(pos.x, -0.866, 0.866), 1).mul(step(0, pos.y.sub(1))))
                return length(pos).mul(sign(pos.y))
        }
        // Hexagonal grid
        const scale = 3
        const scaledPos = uv.mul(scale)
        // Hexagon distance
        const hexDist = hexagon(scaledPos)
        // Create hexagonal pattern
        const pattern = smoothstep(0, 0.1, abs(hexDist).sub(0.5))
        return vec4(vec3(pattern), 1)
}`}
/>

### Kaleidoscope Pattern

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Polar coordinates
        let radius = length(uv.sub(0.5))
        let angle = atan2(uv.sub(0.5).y, uv.sub(0.5).x)
        // Create symmetry
        const segments = 8
        angle = angle.div(float(6)).mul(segments)
        angle = abs(fract(angle).sub(0.5)).mul(2)
        angle = angle.mul(float(6)).div(segments)
        // Convert back to cartesian
        const x = cos(angle).mul(radius)
        const y = sin(angle).mul(radius)
        const symmetricPos = vec2(x, y)
        // Create pattern in symmetric space
        const pattern1 = sin(symmetricPos.x.mul(10))
        const pattern2 = sin(symmetricPos.y.mul(15))
        const combined = pattern1.mul(pattern2)
        // Color based on angle and radius
        const color = vec3(combined, combined.mul(0.8), combined.mul(1.2))
        return vec4(color, 1)
}`}
/>

## Complex Patterns

### Fractal-like Pattern

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        let color = vec3(0)
        // Multiple scales of the same pattern
        for (let i = 0; i < 5; i++) {
                const scale = pow(2, float(i))
                const scaledPos = uv.mul(scale)
                // Circle pattern at each scale
                const dist = length(fract(scaledPos).sub(0.5))
                const circle = smoothstep(0.3, 0.2, dist)
                // Add to final color with decreasing weight
                const weight = oneMinus(float(i).div(5))
                color = color.add(vec3(circle).mul(weight))
        }
        color = color.div(5) // Normalize
        return vec4(color, 1)
}`}
/>

### Voronoi Pattern

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const st = uv.mul(float(5))
        const i = floor(st)
        const j = fract(st)
        const random2 = Fn(([p]) => {
                return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))).mul(43758.5453))
        })
        let minDist = float(1)
        let closestPoint = vec2(0)
        const check = (x, y) => {
                const offset = vec2(float(x), float(y))
                const point = random2(i.add(offset))
                const dist = length(offset.add(point).sub(j))
                const closer = step(dist, minDist)
                minDist = mix(minDist, dist, closer)
                closestPoint = mix(closestPoint, point, closer)
        }
        for (let y = -1; y <= 1; y++)
                for (let x = -1; x <= 1; x++)
                        check(x, y)
        return vec4(vec3(closestPoint, 0.8), 1)
}`}
/>

### Moire Pattern

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Two different frequency stripes
        const freq1 = 20
        const freq2 = 21
        const stripe1 = sin(uv.x.mul(freq1))
        const stripe2 = sin(uv.x.mul(freq2).add(uv.y.mul(0.5)))
        // Interference pattern
        const interference = stripe1.mul(stripe2)
        const pattern = interference
        // Color the pattern
        const color = vec3(pattern, pattern.mul(0.8), pattern.mul(1.2))
        return vec4(color, 1)
}`}
/>

## Dynamic Patterns

### Rotating Shapes

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        const centeredUV = uv.sub(0.5)
        // Rotation matrix using iTime
        const angle = iTime.mul(0.5)
        const cosA = cos(angle)
        const sinA = sin(angle)
        const rotatedPos = vec2(
                centeredUV.x.mul(cosA).sub(centeredUV.y.mul(sinA)),
                centeredUV.x.mul(sinA).add(centeredUV.y.mul(cosA))
        )
        // Triangle using polygon generator
        const polygon = (pos, sides, size) => {
                const angle = atan2(pos.y, pos.x)
                const radius = length(pos)
                const pi2 = float(6.28318)
                const a = angle.add(float(3.14159)).div(pi2).mul(sides)
                const r = cos(floor(a).sub(a).add(float(0.5)).mul(pi2).div(sides))
                return step(radius.mul(r), size)
        }
        const triangle = polygon(rotatedPos, float(3), float(0.08))
        const color = vec3(triangle, triangle.mul(0.7), triangle.mul(1.3))
        return vec4(color, 1)
}`}
/>

### Morphing Patterns

<FragmentEditor
        isFun
        code={`
const fragment = () => {
        // Morphing between different patterns
        const t = sin(iTime)
        // Pattern A: Circles
        const circles = sin(length(uv.sub(0.5)).mul(10))
        // Pattern B: Stripes
        const stripes = sin(uv.x.mul(10))
        // Pattern C: Grid
        const grid = sin(uv.x.mul(10)).mul(sin(uv.y.mul(10)))
        // Morph between patterns
        let pattern = mix(circles, stripes, smoothstep(0, 0.33, t))
        pattern = mix(pattern, grid, smoothstep(0.33, 0.66, t))
        pattern = mix(pattern, circles, smoothstep(0.66, 1, t))
        pattern = pattern
        const color = vec3(pattern, pattern.mul(0.8), pattern.mul(1.2))
        return vec4(color, 1)
}`}
/>

## What You've Learned

- ✅ Basic geometric shapes (circles, polygons, stars)
- ✅ Line and curve drawing techniques
- ✅ Grid and tiling patterns
- ✅ Complex pattern generation (fractals, voronoi, moire)
- ✅ Dynamic and animated patterns

## Next Steps

Now that you can create shapes and patterns, learn about [Images and Textures](05-images-textures.md) to work with external images and create complex surface effects.
